<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Pixel Space</title>
    <link>http://git.bookislife.com/topics/android/</link>
    <description>Recent content in Android on Pixel Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright (c) 2015, Sidney Xu; all rights reserved.</copyright>
    <lastBuildDate>Wed, 23 Sep 2015 11:55:29 +0800</lastBuildDate>
    <atom:link href="http://git.bookislife.com/topics/android/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>如何开发 JNI 应用</title>
      <link>http://git.bookislife.com/post/2015/how-to-develop-jni-app/</link>
      <pubDate>Wed, 23 Sep 2015 11:55:29 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/how-to-develop-jni-app/</guid>
      <description>

&lt;h2 id=&#34;传统-jni-开发步骤:6a26598dccbc474410e9b9e3c353078a&#34;&gt;传统 JNI 开发步骤&lt;/h2&gt;

&lt;h3 id=&#34;总述:6a26598dccbc474410e9b9e3c353078a&#34;&gt;总述&lt;/h3&gt;

&lt;p&gt;Android 的 JNI 开发一般可以总结为以下步骤&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编写含有 Native 方法的 Java 类&lt;/li&gt;
&lt;li&gt;用 javah 生成 C/C++ 原生函数的头文件&lt;/li&gt;
&lt;li&gt;用 C/C++ 实现原生函数&lt;/li&gt;
&lt;li&gt;将项目依赖的原生库和资源添加到工程中&lt;/li&gt;
&lt;li&gt;生成应用&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;在类中追加-native-方法:6a26598dccbc474410e9b9e3c353078a&#34;&gt;在类中追加 native 方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Hello {
    public native String hellojni();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;生成头文件:6a26598dccbc474410e9b9e3c353078a&#34;&gt;生成头文件&lt;/h3&gt;

&lt;p&gt;在当前模块目录下追加一个 shell 文件，该文件用于生成头文件&lt;/p&gt;

&lt;p&gt;hello.sh&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
export ProjectPath=$(cd &amp;quot;.&amp;quot;; pwd)
#echo $ProjectPath

export TargetClassName=&amp;quot;com.example.jni.Hello&amp;quot;
export SourceFile=&amp;quot;${ProjectPath}/src/main/java&amp;quot;
export TargetPath=&amp;quot;${ProjectPath}/src/main/jni&amp;quot;

#echo $SourceFile
cd &amp;quot;${SourceFile}&amp;quot;
javah -d ${TargetPath} -classpath &amp;quot;${SourceFile}&amp;quot; &amp;quot;${TargetClassName}&amp;quot;
echo -d ${TargetPath} -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TargetClassName&lt;/code&gt; 为含有 native 方法的类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SourceFile&lt;/code&gt; 为 Java 源代码目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TargetPath&lt;/code&gt; 为 jni 源代码目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行 shell 文件 &lt;code&gt;sh hello.sh&lt;/code&gt;，在目录 &lt;code&gt;src/main/jni&lt;/code&gt; 下会发现生成的.h 头文件&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;p&gt;com_example_jni_Hello.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* DO NOT EDIT THIS FILE - it is machine generated */
#include &amp;lt;jni.h&amp;gt;
/* Header for class com_example_jni_Hello */

#ifndef _Included_com_example_jni_Hello
#define _Included_com_example_jni_Hello
#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
/*
 * Class:     com_example_jni_Hello
 * Method:    hellojni
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_jni_Hello_hellojni
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;编写-jni-代码:6a26598dccbc474410e9b9e3c353078a&#34;&gt;编写 JNI 代码&lt;/h3&gt;

&lt;p&gt;根据头文件，在 jni 目录下创建对应的.c/.cpp 文件，完成代码&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;p&gt;hello.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;com_example_jni_Hello.h&amp;quot;
/*
 * Class:     com_example_jni_Hello
 * Method:    hellojni
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_jni_Hello_hellojni
  (JNIEnv *env, jobject){
    return env-&amp;gt;NewStringUTF( &amp;quot;hello from jni&amp;quot;);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;配置-ndk-环境:6a26598dccbc474410e9b9e3c353078a&#34;&gt;配置 NDK 环境&lt;/h3&gt;

&lt;p&gt;下载 NDK，并在工程目录下新建 &lt;code&gt;local.properties&lt;/code&gt; 文件，在其中追加 &lt;code&gt;ndk.dir&lt;/code&gt; 属性，值为 NDK 的路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ndk.dir=/Users/localUser/Documents/android-ndk-r10d
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;编译-jni-代码:6a26598dccbc474410e9b9e3c353078a&#34;&gt;编译 JNI 代码&lt;/h3&gt;

&lt;p&gt;选择当前模块 -&amp;gt; 右键选择 &lt;code&gt;Make Module&lt;/code&gt; 后编译代码，完成后在 &lt;code&gt;build/intermediates/ndk&lt;/code&gt; 目录下会生成对应的 &lt;code&gt;Android.mk&lt;/code&gt; 文件和 &lt;code&gt;xx.so&lt;/code&gt; 文件（如果出现错误，需要注意 ndk 下的 &lt;code&gt;platform&lt;/code&gt; 目录下是否有当前的 sdk 版本，没有的话需要更新 ndk）。&lt;/p&gt;

&lt;h3 id=&#34;载入-library-运行代码:6a26598dccbc474410e9b9e3c353078a&#34;&gt;载入 Library，运行代码&lt;/h3&gt;

&lt;p&gt;打开拥有 native 方法的类，加入以下语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static {
  System.loadLibrary(libraryName );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;libraryName&lt;/code&gt; 就是上一节 &lt;code&gt;Android.mk&lt;/code&gt; 文件中的 &lt;code&gt;LOCAL_MODULE&lt;/code&gt; 名，Gradle 默认生成的 &lt;code&gt;libraryName&lt;/code&gt; 就是当前的模块名，所以如果你用默认配置的话应该就是 &lt;code&gt;app&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以上都完成后，就可以运行代码查看效果了。&lt;/p&gt;

&lt;h3 id=&#34;自定义配置:6a26598dccbc474410e9b9e3c353078a&#34;&gt;自定义配置&lt;/h3&gt;

&lt;p&gt;包含 moduleName 等可以通过修改 build.gradle 文件进行一些自定义配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;debug {
  ndk {
    //  自定义 library 名
    moduleName &amp;quot;jnimain&amp;quot;

    //  指定生成的 xx.so 平台
    abiFilters &amp;quot;armeabi&amp;quot;, &amp;quot;armeabi-v7a&amp;quot;

    stl &amp;quot;stlport_shared&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基于最新-android-studio-进行-jni-开发:6a26598dccbc474410e9b9e3c353078a&#34;&gt;基于最新 Android Studio 进行 JNI 开发&lt;/h2&gt;

&lt;p&gt;最新的 Android Studio 使用了新的一套配置来进行 JNI 开发，并且其内置了 NDK 的 Debug 机能。不过目前这种配置还是实验性的，所以与以前的方式相比较需要改动不少地方。&lt;/p&gt;

&lt;h3 id=&#34;环境:6a26598dccbc474410e9b9e3c353078a&#34;&gt;环境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Android Studio 1.3 RC1 以上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Gradle 2.5，目前仅支持 2.5，其它版本的 Gradle 都不行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlqqp.com1.z0.glb.clouddn.com/jni/sdk.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;修改-build-gradle-配置:6a26598dccbc474410e9b9e3c353078a&#34;&gt;修改 build.gradle 配置&lt;/h3&gt;

&lt;p&gt;根目录 build.gradle&lt;/p&gt;

&lt;p&gt;注意 &lt;code&gt;classpath&lt;/code&gt; 由原来的 &lt;code&gt;classpath &#39;com.android.tools.build:gradle:1.3.+’&lt;/code&gt; 变为了以下这种&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle-experimental:0.2.0&#39;
    }
}

allprojects {
    repositories {
        jcenter()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;工程目录 build.gradle&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;apply plugin: &#39;com.android.model.application&#39;

repositories {
    jcenter()
}

model {
    android {
        compileSdkVersion = 22
        buildToolsVersion = &amp;quot;22.0.1&amp;quot;

        defaultConfig.with {
            applicationId = &amp;quot;com.example.jni&amp;quot;
            minSdkVersion.apiLevel = 9
            targetSdkVersion.apiLevel = 22
            versionCode = 1
            versionName = &amp;quot;1.0&amp;quot;
        }
    }
    android.buildTypes {
        release {
            minifyEnabled = false
            proguardFiles += file(&#39;proguard-rules.pro&#39;)
        }
        debug {
            ndk.with {
                debuggable = true
            }
        }
    }
    android.ndk {
        moduleName = &amp;quot;app&amp;quot;
    }
    compileOptions.with {
        sourceCompatibility = JavaVersion.VERSION_1_7
        targetCompatibility = JavaVersion.VERSION_1_7
    }
}

dependencies {
    compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)
    compile &#39;com.android.support:appcompat-v7:22.2.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意几点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;plugin 由 &lt;code&gt;com.android.application&lt;/code&gt; 变为 &lt;code&gt;com.android.model.application&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;android{}&lt;/code&gt; 移到了 &lt;code&gt;model{}&lt;/code&gt; 下&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;minSdkVersion&lt;/code&gt; 等变为了 &lt;code&gt;minSdkVersion.apiLevel&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;defaultConfig&lt;/code&gt; 等变为了 &lt;code&gt;defaultConfig.with&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;compileSdkVersion 22&lt;/code&gt; 之类的都变成了 &lt;code&gt;compileSdkVersion = 22&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;进行-debug:6a26598dccbc474410e9b9e3c353078a&#34;&gt;进行 Debug&lt;/h3&gt;

&lt;p&gt;以上修改完毕后，选择 &lt;code&gt;Edit Configurations&lt;/code&gt; -&amp;gt; 新建 &lt;code&gt;Android Native&lt;/code&gt;，以 Debug 形式运行此配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlqqp.com1.z0.glb.clouddn.com/jni/config.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;在工程的 native 代码中打上断点，就可以进行 native 代码相关的 debug 了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlqqp.com1.z0.glb.clouddn.com/jni/debug.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;参考资料:6a26598dccbc474410e9b9e3c353078a&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tools.android.com/tech-docs/android-ndk-preview&#34;&gt;Android NDK Preview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tools.android.com/tech-docs/new-build-system/gradle-experimental&#34;&gt;Experimental Plugin User Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/eaglesakura/items/c4af7989b03904d66ebe&#34;&gt;Android StudioのNDK開発機能を使おう！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整的 Android 示例见 &lt;a href=&#34;https://github.com/SidneyXu/templates/tree/master/hello-jni&#34;&gt;hello-jni&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>