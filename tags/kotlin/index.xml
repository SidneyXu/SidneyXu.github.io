<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kotlin on Pixel Space</title>
    <link>http://git.bookislife.com/tags/kotlin/</link>
    <description>Recent content in Kotlin on Pixel Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright (c) 2015, Sidney Xu; all rights reserved.</copyright>
    <lastBuildDate>Thu, 31 Dec 2015 07:02:22 +0800</lastBuildDate>
    <atom:link href="http://git.bookislife.com/tags/kotlin/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JGSK - Kotlin - 08.Utils</title>
      <link>http://git.bookislife.com/post/2015/jgsk-kotlin-08-utils/</link>
      <pubDate>Thu, 31 Dec 2015 07:02:22 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-kotlin-08-utils/</guid>
      <description>

&lt;h2 id=&#34;utils:588f0a949b6f820f718d945c8b39eee6&#34;&gt;Utils&lt;/h2&gt;

&lt;p&gt;本章主要介绍一些 Kotlin 内置的工具类和方法。&lt;/p&gt;

&lt;h3 id=&#34;preconditions:588f0a949b6f820f718d945c8b39eee6&#34;&gt;Preconditions&lt;/h3&gt;

&lt;h4 id=&#34;基础概念:588f0a949b6f820f718d945c8b39eee6&#34;&gt;基础概念&lt;/h4&gt;

&lt;p&gt;Preconditions（前提条件）主要用于对方法中传入的参数进行基础校验。&lt;/p&gt;

&lt;h4 id=&#34;require-和-check:588f0a949b6f820f718d945c8b39eee6&#34;&gt;require 和 check&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;require&lt;/code&gt; 用于检查布尔表达式是否为真。其本身接收两个参数，第一个为等待校验的布尔值，第二个为当校验不通过时显示的消息，该消息将用于构造一个 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 异常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;require(msg.isNotEmpty()) {
    &amp;quot;Message is empty!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;check&lt;/code&gt; 使用同 &lt;code&gt;require&lt;/code&gt;，只是返回的为 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常。&lt;/p&gt;

&lt;h4 id=&#34;requirenotnull-和-checknotnull:588f0a949b6f820f718d945c8b39eee6&#34;&gt;requireNotNull 和 checkNotNull&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;requireNotNull&lt;/code&gt; 用于检查参数是否为空。其本身接收两个参数，第一个为等待校验的参数，第二个为当校验不通过时显示的消息，该消息将用于构造一个 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 异常。当校验通过后， &lt;code&gt;requireNotNull&lt;/code&gt; 会将传入的参数作为返回值进行原样返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val result = requireNotNull(msg) {
    &amp;quot;Object is null!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通用 &lt;code&gt;checkNotNull&lt;/code&gt; 使用同 &lt;code&gt;requireNotNull&lt;/code&gt;，只是返回的为 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常。&lt;/p&gt;

&lt;h4 id=&#34;各种校验实现的比较:588f0a949b6f820f718d945c8b39eee6&#34;&gt;各种校验实现的比较&lt;/h4&gt;

&lt;p&gt;不使用前提条件时，一般的校验方式为如下形式，通过 &lt;code&gt;if&lt;/code&gt; 语句来实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;if (msg.isEmpty()) {
    throw IllegalArgumentException(&amp;quot;Message is empty!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 Java 内置的断言机制&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;assert msg.isNotEmpty()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Google 的 Guava 包种的校验方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Preconditions.checkArgument(msg.isNotEmpty(), &amp;quot;Message is empty!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中通过 &lt;code&gt;if&lt;/code&gt; 语句进行校验通常需要大量重复的语句。通过断言机制的话则只能检查表达式是否为真，并且无法定义易读的错误消息，此外断言是可以被禁止的。使用 Guava 的方式在与 Kotlin 提供的方式类似，但是 Kotlin 的消息构造是惰性加载的，所以效率上要高于 Guava。&lt;/p&gt;

&lt;h3 id=&#34;notimplementederror:588f0a949b6f820f718d945c8b39eee6&#34;&gt;NotImplementedError&lt;/h3&gt;

&lt;p&gt;一般而言在写程序时我们通常将有待实现的方法上加上注释 &lt;code&gt;// TODO&lt;/code&gt; 来标示该方法，但是对于调用者来说除非查看源码否则他没有办法知道这种信息。Kotlin 提供了 NotImplementedError&lt;code&gt;异常用于表示这种情况。除此之外，Kotlin 还提供了一个内部方法&lt;/code&gt;TODO()` 用于抛出这种异常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;TODO(&amp;quot;Not implemented in current version&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;计算执行时间:588f0a949b6f820f718d945c8b39eee6&#34;&gt;计算执行时间&lt;/h3&gt;

&lt;p&gt;Kotlin 内部提供了工具方法 &lt;code&gt;measureTimeMillis()&lt;/code&gt; 可以用于计算代码块的耗时时间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val duration = measureTimeMillis {
    var counter = 0
    repeat(100000000) {
        counter++
    }
}
println(&amp;quot;duration is $duration&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - Kotlin - 07.内联函数</title>
      <link>http://git.bookislife.com/post/2015/jgsk-kotlin-07-inline-function/</link>
      <pubDate>Wed, 30 Dec 2015 13:13:35 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-kotlin-07-inline-function/</guid>
      <description>

&lt;h2 id=&#34;内联函数:1b34e32525c7e9224d713389da0255ad&#34;&gt;内联函数&lt;/h2&gt;

&lt;h3 id=&#34;概念:1b34e32525c7e9224d713389da0255ad&#34;&gt;概念&lt;/h3&gt;

&lt;p&gt;普通函数在执行时程序会跳转到函数定义处执行完毕后再返回调用处。而内联函数指的是函数定义被整个复制到了调用处，所以与普通函数相比，内联函数无需进行程序的跳转，有助于提高程序的运行速度。但是大量的内联函数会增大应用的体积，从而减慢应用的加载速度。&lt;/p&gt;

&lt;p&gt;特别注意，内联函数不是内嵌函数，内嵌函数是函数中定义函数，两者只差一个字，但是意义完全不同。&lt;/p&gt;

&lt;p&gt;Java 平台一直都是支持内联函数的，但是开发者无法自行指定任何函数为内联函数。内联这一操作本身是由 JVM 在运行时自动决定的。而 Kotlin 提供了在编译器进行内联的功能。&lt;/p&gt;

&lt;h3 id=&#34;定义内联函数:1b34e32525c7e9224d713389da0255ad&#34;&gt;定义内联函数&lt;/h3&gt;

&lt;p&gt;定义内联函数只需要在普通函数前面加上 &lt;code&gt;inline&lt;/code&gt; 关键字即可。需要特别注意的是内联操作不仅对函数体有效，也对函数参数有效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;//  内联函数
inline fun &amp;lt;T&amp;gt; inlineLock(lock: Lock, body: () -&amp;gt; T): T {
    lock.lock()
    try {
        return body()
    } finally {
        lock.unlock()
    }
}

//  普通函数
fun echo() = println(&amp;quot;foo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用该内联函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val lock = ReentrantLock()
inlineLock(lock, { echo() })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码会被编译成以下代码，即函数体和作为参数的 Lambda 表达式都被替换成了实际代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val lock = ReentrantLock()
lock.lock()
try {
    println(&amp;quot;foo&amp;quot;)
} finally {
    lock.unlock()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;noinline:1b34e32525c7e9224d713389da0255ad&#34;&gt;noinline&lt;/h3&gt;

&lt;p&gt;有时我们希望定义内联函数时只要对函数体有效，不要对参数有效，可以在参数前加上 &lt;code&gt;noinline&lt;/code&gt; 关键字取消参数的内联操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun &amp;lt;T&amp;gt; inlineLock(lock: Lock, body: () -&amp;gt; T,
                          noinline notInlined: () -&amp;gt; T): T {
    lock.lock()
    try {
        return body()
    } finally {
        lock.unlock()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;non-local-returns:1b34e32525c7e9224d713389da0255ad&#34;&gt;Non-local Returns&lt;/h3&gt;

&lt;p&gt;我们知道在函数中定义的函数或闭包如果调用 &lt;code&gt;return&lt;/code&gt; 语句只能退出其当前所在的闭合语句块，即本地返回，而无法退出外层函数。而内联函数由于是被直接复制到了调用处，所以其支持非本地返回(Non-local returns)，即调用 &lt;code&gt;return&lt;/code&gt; 时会退出外层函数。&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;p&gt;定义一个内联函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun contains(f: () -&amp;gt; Boolean): Boolean {
    return f()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义一个调用内联函数的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun localReturn(list: List&amp;lt;Int&amp;gt;): Boolean {
    contains {
        for (i in list) {
            if (i == 0) return true
        }
        return false
    }
    return false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上 &lt;code&gt;contains&lt;/code&gt; 中的 &lt;code&gt;return&lt;/code&gt; 语句会直接返回到 &lt;code&gt;localReturn()&lt;/code&gt; 的调用处，而不是退出 &lt;code&gt;contains&lt;/code&gt; 语句块。&lt;/p&gt;

&lt;p&gt;这种特性在很多时候很有用，但是有时我们定义的内联函数并不会立即在当前环境执行，而是放在诸如线程中执行，这时调用该函数的时候就不能依靠它的返回值来控制流程，为了标志这种情况可以在参数上加上关键字 &lt;code&gt;crossinline&lt;/code&gt;，这样调用处会在编译时就报错避免错误调用。&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun crosslineFun(crossinline f: () -&amp;gt; Unit): Unit {
    Thread {
        f()
    }.start()
}
fun crosslineReturn(list: List&amp;lt;Int&amp;gt;): Unit {
    crosslineFun {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;类型参数:1b34e32525c7e9224d713389da0255ad&#34;&gt;类型参数&lt;/h3&gt;

&lt;p&gt;有时候我们希望将类型作为参数进行传递，在 Java 中主要依赖反射的机制，将 &lt;code&gt;Class&lt;/code&gt; 对象作为进行传递。&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun &amp;lt;T&amp;gt; TreeNode.findParentOfType(clazz: Class&amp;lt;T&amp;gt;): T? {
    var p = parent
    while (p != null &amp;amp;&amp;amp; !clazz.isInstance(p)) {
        p = p.parent
    }
    @Suppress(&amp;quot;UNCHECKED_CAST&amp;quot;)
    return p as T
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用以上函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val root = DefaultMutableTreeNode(&amp;quot;root&amp;quot;)
val node1 = DefaultMutableTreeNode(&amp;quot;node1&amp;quot;)
val node1_1 = DefaultMutableTreeNode(&amp;quot;node1_1&amp;quot;)
val node2 = DefaultMutableTreeNode(&amp;quot;node2&amp;quot;)
node1.add(node1_1)
root.add(node1)
root.add(node2)

var parent = node1_1.findParentOfType(DefaultMutableTreeNode::class.java)
println(parent) //  node1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到由于依赖于反射，所以在函数体内不但要处理未检查类型转换的警告也很难处理具体类型的信息。&lt;/p&gt;

&lt;p&gt;而内联函数由于是复制到调用处，所以实际在运行时无需依赖反射，可以直接得到真实类型。要开启此功能，只需在泛型参数前加上 &lt;code&gt;reified&lt;/code&gt; 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline fun &amp;lt;reified T&amp;gt; TreeNode.inlineFindParentOfType(): T? {
    var p = parent
    while (p != null &amp;amp;&amp;amp; p !is T) {
        p = p.parent
    }
    return p as T
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用该函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;parent = node1_1.inlineFindParentOfType()
println(parent) //  node1
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - Kotlin - 06.DSL</title>
      <link>http://git.bookislife.com/post/2015/jgsk-kotlin-06-dsl/</link>
      <pubDate>Wed, 30 Dec 2015 12:38:09 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-kotlin-06-dsl/</guid>
      <description>

&lt;h2 id=&#34;dsl:8feaa10a0f275f58a6767e04e3435ebe&#34;&gt;DSL&lt;/h2&gt;

&lt;p&gt;DSL 即 domain-specific languages，领域特定语言。和一般的编程语言不同，领域特定语言只能用于特定的领域中并且表现形式有限。领域特定语言最大的功能就是可以让语言本身更容易阅读，方便开发者和领域专家进行交流。&lt;/p&gt;

&lt;h3 id=&#34;实现-dsl:8feaa10a0f275f58a6767e04e3435ebe&#34;&gt;实现 DSL&lt;/h3&gt;

&lt;p&gt;Java 中 DSL 的最简单实现方式就是构造器模式，而在 Kotlin 过去的版本中可以省略 &lt;code&gt;.&lt;/code&gt;，所以可以写成更易读的代码，但是现在的版本已经不支持了。&lt;/p&gt;

&lt;p&gt;构造器模式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Machine machine = new Machine.Builder()
    .setCore(8)
    .setArch(&amp;quot;64 bits&amp;quot;)
    .setOs(&amp;quot;Linux&amp;quot;)
    .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DSL 方式&lt;/p&gt;

&lt;p&gt;定义必要的类和方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;data class Cpu(val core: Int, val arch: String)

class Machine {
    var cpu: Cpu? = null
    var os: String? = null

    fun having(cores: Int, arch: String): Machine {
        cpu = Cpu(cores, arch)
        return this
    }

    fun os(os: String): Machine {
        this.os = os
        return this
    }

    override fun toString(): String {
        return &amp;quot;Machine{cpu=$cpu, os=&#39;$os&#39;&amp;quot;
    }

}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val m1 = Machine().having(8, &amp;quot;64 bits&amp;quot;).os(&amp;quot;linux&amp;quot;)
val m2 = Machine().having(4, &amp;quot;32 bits&amp;quot;).os(&amp;quot;Windows&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到使用 DSL 后代码更加易读。&lt;/p&gt;

&lt;h3 id=&#34;使用闭包构建-dsl:8feaa10a0f275f58a6767e04e3435ebe&#34;&gt;使用闭包构建 DSL&lt;/h3&gt;

&lt;p&gt;Kotlin 像 Groovy 一样也能通过闭包构建 DSL，语法看起来很像 Groovy。&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;p&gt;定义必要的类和方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class EmailSpec {
    fun from(from: String) = println(&amp;quot;From: $from&amp;quot;)
    fun to(to: String) = println(&amp;quot;To: $to&amp;quot;)
    fun subject(subject: String) = println(&amp;quot;Subject: $subject&amp;quot;)
    fun body(init: BodySpec.() -&amp;gt; Unit): BodySpec {
        val body = BodySpec()
        body.init()
        return body
    }
}

class BodySpec {
    fun p(p: String) = println(&amp;quot;P: $p&amp;quot;)
}

fun email(init: EmailSpec.() -&amp;gt; Unit): EmailSpec {
    val email = EmailSpec()
    email.init()
    return email
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用 DSL 语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;email {
    from (&amp;quot;dsl-guru@mycompany.com&amp;quot;)
    to (&amp;quot;john.doe@waitaminute.com&amp;quot;)
    subject (&amp;quot;The pope has resigned!&amp;quot;)
    body {
        p (&amp;quot;Really, the pope has resigned!&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - Kotlin - 05.高阶函数</title>
      <link>http://git.bookislife.com/post/2015/jgsk-kotlin-05-high-order-function/</link>
      <pubDate>Tue, 29 Dec 2015 12:22:04 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-kotlin-05-high-order-function/</guid>
      <description>

&lt;h2 id=&#34;高阶函数:587612d144dc356ef53d9fcc54339e98&#34;&gt;高阶函数&lt;/h2&gt;

&lt;h3 id=&#34;函数字面量:587612d144dc356ef53d9fcc54339e98&#34;&gt;函数字面量&lt;/h3&gt;

&lt;p&gt;所谓的函数字面量指的将函数本身赋值给一个变量。通过函数字面量，可以使函数本身表现得和普通变量一样。&lt;/p&gt;

&lt;p&gt;定义一个函数字面量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt; val sum = { x: Int, y: Int -&amp;gt; x + y }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kotlin 在定义函数字面量时支持参数的类型推断，只要确定了返回值的类型，编写参数时就可以省略类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val sum2: (Int, Int) -&amp;gt; Int = { x, y -&amp;gt; x + y }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上函数的返回值类型为 &lt;code&gt;(Int, Int) -&amp;gt; Int&lt;/code&gt;，表示函数有两个整型的输入和一个整型的返回值，所以定义参数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 时可以省略参数类型。&lt;/p&gt;

&lt;p&gt;Scala 中实现函数字面量的方法比较特别，是通过一个名为 &lt;code&gt;FunctionN&lt;/code&gt; (n 为 0 到 22 的整数)的特质的 &lt;code&gt;apply()&lt;/code&gt; 来实现的。其中 &lt;code&gt;Functon0&lt;/code&gt; 代表没有参数，&lt;code&gt;Function1&lt;/code&gt; 代表 1 个参数，以此类推。&lt;/p&gt;

&lt;p&gt;所以以上 &lt;code&gt;sum2&lt;/code&gt; 实质上是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val sum2: Function2[Int, Int, Int] = new Function2[Int, Int, Int] {
  override def apply(x: Int, y: Int): Int = x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;高阶函数-1:587612d144dc356ef53d9fcc54339e98&#34;&gt;高阶函数&lt;/h3&gt;

&lt;p&gt;高级函数指的是将函数本身作为参数传递给另一个函数或者一个函数返回值是另一个函数。正是由于函数字面值的存在，高阶函数才能得以实现。&lt;/p&gt;

&lt;h4 id=&#34;函数作为参数:587612d144dc356ef53d9fcc54339e98&#34;&gt;函数作为参数&lt;/h4&gt;

&lt;p&gt;定义一个参数为函数类型的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun add10(f: (Int) -&amp;gt; Int) = f(10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上定义了一个函数 &lt;code&gt;add10()&lt;/code&gt;，该函数接收一个以整型为输入并返回整型的函数类型参数，在函数体中会调用传入的函数并向其传入参数 10。&lt;/p&gt;

&lt;p&gt;调用以上方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;add10({ it + 2 })   //  12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码可以简写成以下形式，省略掉参数外的括号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;add10 { it + 2 }   //  12
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;函数作为返回值:587612d144dc356ef53d9fcc54339e98&#34;&gt;函数作为返回值&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun scale(factor: Double) = { x: Double -&amp;gt; x * factor }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;柯里化:587612d144dc356ef53d9fcc54339e98&#34;&gt;柯里化&lt;/h3&gt;

&lt;p&gt;柯里化 (Currying) 指的是将一个接收多个参数的函数分解成多个接收单个参数的函数的一种技术。令人惊讶的是 Kotlin 居然也没有柯里化的语法糖，所以必须自己实现层层嵌套的比较丑陋的语法结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;def show2(String prefix) {
    return { String msg -&amp;gt;
        return { String postfix -&amp;gt;
            return prefix + msg + postfix
        }
    }
}
show2(&amp;quot;(&amp;quot;)(&amp;quot;foobar&amp;quot;)(&amp;quot;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;函数的部分应用:587612d144dc356ef53d9fcc54339e98&#34;&gt;函数的部分应用&lt;/h3&gt;

&lt;p&gt;函数的部分应用 (Function Partial Application) 指的是向一个接收多个参数的函数传入部分参数从而获得一个接收剩余参数的新函数的技术。&lt;/p&gt;

&lt;p&gt;Kotlin 目前没有提供部分应用的语法糖。&lt;/p&gt;

&lt;h3 id=&#34;扩展函数作为参数:587612d144dc356ef53d9fcc54339e98&#34;&gt;扩展函数作为参数&lt;/h3&gt;

&lt;p&gt;由于 Kotlin 支持函数扩展，所以可以将扩展的函数作为函数的参数。&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun accept(dec: Int.(other: Int) -&amp;gt; Int): Int {
    //  定义了一个 Receiver
    val i = 100
    return i.dec(10)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上 &lt;code&gt;accept()&lt;/code&gt; 接收一个以 &lt;code&gt;Int&lt;/code&gt; 类型作为 Receiver 的函数，该函数接收一个 &lt;code&gt;Int&lt;/code&gt; 类型的参数并且返回 &lt;code&gt;Int&lt;/code&gt; 类型。在 &lt;code&gt;accept()&lt;/code&gt; 中定义了一个 值为 &lt;code&gt;100&lt;/code&gt; 的 Receiver。&lt;/p&gt;

&lt;p&gt;调用该函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val a = accept { x -&amp;gt;
    this + x
}
println(a)  //  110
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要特别注意其于将函数作为参数时的区别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun accept2(f: (Int) -&amp;gt; Int): Int {
    return f(10)
}

val b = accept2 { x -&amp;gt;
    x + 10
}
println(b)  //  20
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - 35.集合的函数式编程</title>
      <link>http://git.bookislife.com/post/2015/jgsk-35-collection-function/</link>
      <pubDate>Fri, 25 Dec 2015 11:48:59 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-35-collection-function/</guid>
      <description>

&lt;h2 id=&#34;java:152af32176ddf9979e854df274b7c621&#34;&gt;Java&lt;/h2&gt;

&lt;p&gt;从 Java 1.8 开始 Java 也支持了集合的函数式编程。&lt;/p&gt;

&lt;h3 id=&#34;stream:152af32176ddf9979e854df274b7c621&#34;&gt;Stream&lt;/h3&gt;

&lt;p&gt;Stream 是 Java 1.8 引入的类，主要用于进行 并行集合的流式操作。&lt;/p&gt;

&lt;p&gt;集合可以使用调用 &lt;code&gt;stream()&lt;/code&gt; 方法或者使用 &lt;code&gt;Stream&lt;/code&gt; 类的静态方法来转换为 &lt;code&gt;Stream&lt;/code&gt; 对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; numbers1 = Arrays.asList(1, 2, 3, 4, 5, 6);
List&amp;lt;Integer&amp;gt; numbers2 = Arrays.asList(10, 20, 30);
List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; numbers3 = Arrays.asList(numbers1, numbers2);

numbers1.stream();
Stream.of(numbers1);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;map-操作:152af32176ddf9979e854df274b7c621&#34;&gt;Map 操作&lt;/h3&gt;

&lt;p&gt;Map 操作用于对集合中的每一个输入元素应用指定的函数从而得到另一种输出。输入类型和输出类型可以不一致。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; mapResult = numbers1.stream().map(x -&amp;gt; x * x);
System.out.println(&amp;quot;map =&amp;gt; &amp;quot; + getString(mapResult));   //  [1, 4, 9, 16, 25, 36]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flatmap-操作:152af32176ddf9979e854df274b7c621&#34;&gt;FlatMap 操作&lt;/h3&gt;

&lt;p&gt;FlatMap 操作用于对输入元素进行抽出，得到扁平化的输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; flatMapResult = numbers3.stream().flatMap(list -&amp;gt; list.stream().map(x -&amp;gt; x * 10));
System.out.println(&amp;quot;flatMap =&amp;gt; &amp;quot; + getString(flatMapResult));   //  [10, 20, 30, 40, 50, 60, 100, 200, 300]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reduce-操作:152af32176ddf9979e854df274b7c621&#34;&gt;Reduce 操作&lt;/h3&gt;

&lt;p&gt;Reduce 操作用于对集合中的每一个元素进行指定的计算从而得到计算结果。计算的过程是将第一个元素和第二个元素进行计算，得到的结果和第三个元素再进行计算，以此类推。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Optional&amp;lt;Integer&amp;gt; reduceResult = numbers1.stream().reduce((n1, n2) -&amp;gt; n1 - n2;
System.out.println(&amp;quot;reduce =&amp;gt; &amp;quot; + reduceResult.get());  //  -19
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filter-操作:152af32176ddf9979e854df274b7c621&#34;&gt;Filter 操作&lt;/h3&gt;

&lt;p&gt;Filter 操作通过对集合中的每一个元素应用一个返回值是布尔值的函数来获得一个返回值都是 &lt;code&gt;true&lt;/code&gt; 的新的集合.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; filterResult = numbers1.stream().filter(n -&amp;gt; n % 2 == 0);
System.out.println(&amp;quot;filter =&amp;gt; &amp;quot; + getString(filterResult)); //  [2, 4, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;collect-操作:152af32176ddf9979e854df274b7c621&#34;&gt;Collect 操作&lt;/h3&gt;

&lt;p&gt;Collect 操作接收偏函数并返回偏函数处理的分组的结果集。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt; collectResult = numbers1.stream().collect(Collectors.partitioningBy(x -&amp;gt; x % 2 == 0));
System.out.println(&amp;quot;collect =&amp;gt; &amp;quot; + collectResult);  //  {false=[1, 3, 5], true=[2, 4, 6]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;foreach-操作:152af32176ddf9979e854df274b7c621&#34;&gt;ForEach 操作&lt;/h3&gt;

&lt;p&gt;ForEach 操作用于对集合进行遍历。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;numbers1.stream().forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parallel-操作:152af32176ddf9979e854df274b7c621&#34;&gt;Parallel 操作&lt;/h3&gt;

&lt;p&gt;Stream 操作默认都是单线程的。但是可以使用 ParallelStream 进行并发的流式操作，并发默认使用 &lt;code&gt;ForkJoinPool.commonPool&lt;/code&gt;。ParallelStream 和 Stream 在使用上唯一区别就是使用 &lt;code&gt;parallelStream()&lt;/code&gt; 替代 &lt;code&gt;stream()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;numbers1.parallelStream().forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 ParallelStream 时集合中的某一个元素完成当前流的计算后就会立即进入下一个控制流，而不会像 Stream 一样只有集合的所有元素都完成操作后才会进行下一个控制流。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; parallelResult = numbers1.parallelStream().map(x -&amp;gt; {
    System.out.println(&amp;quot;stream first: &amp;quot; + x + &amp;quot; on &amp;quot; + Thread.currentThread().getName());
    return x;
}).map(x -&amp;gt; {
    System.out.println(&amp;quot;stream second: &amp;quot; + x + &amp;quot; on &amp;quot; + Thread.currentThread().getName());
    return x;
}).map(x -&amp;gt; {
    System.out.println(&amp;quot;stream third: &amp;quot; + x + &amp;quot; on &amp;quot; + Thread.currentThread().getName());
    return x;
});
System.out.println(getString(parallelResult));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;groovy:152af32176ddf9979e854df274b7c621&#34;&gt;Groovy&lt;/h2&gt;

&lt;p&gt;Groovy 也提供了部分函数式操作的方法，不过这些方法的命名和其它语言相比都比较奇特，需要额外注意。&lt;/p&gt;

&lt;h3 id=&#34;map-操作-1:152af32176ddf9979e854df274b7c621&#34;&gt;Map 操作&lt;/h3&gt;

&lt;p&gt;Map 操作用于对集合中的每一个输入元素应用指定的函数从而得到另一种输出。输入类型和输出类型可以不一致。Groovy 中的 Map 操作称为 &lt;code&gt;collect&lt;/code&gt;，不要与 Scala 中的 Collect 操作搞混。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def numbers1 = [1, 2, 3, 4, 5, 6]
def numbers2 = [10, 20, 30]
def numbers3 = [numbers1, numbers2]
def mapResult = numbers1.collect { it * it }
println(&amp;quot;map =&amp;gt; ${mapResult}&amp;quot;)    //  [1, 4, 9, 16, 25, 36]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flatmap-操作-1:152af32176ddf9979e854df274b7c621&#34;&gt;FlatMap 操作&lt;/h3&gt;

&lt;p&gt;FlatMap 操作用于对输入元素进行抽出，得到扁平化的输出。Groovy 中的 FlatMap 操作被称为 &lt;code&gt;collectMany&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def flatMapResult = numbers3.collectMany { it.collect { it * 10 } }
println(&amp;quot;flatMap =&amp;gt; ${flatMapResult}&amp;quot;)    //   [10, 20, 30, 40, 50, 60, 100, 200, 300]              
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只是想简单的抽出的话，可以直接使用更简单的 &lt;code&gt;flatten()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;println(&amp;quot;flatten =&amp;gt; ${numbers3.flatten()}&amp;quot;)    //  [1, 2, 3, 4, 5, 6, 10, 20, 30]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zip-操作:152af32176ddf9979e854df274b7c621&#34;&gt;Zip 操作&lt;/h3&gt;

&lt;p&gt;Zip 操作用于连接两个集合，新的集合以最短的集合为准。Groovy 中的 Zip 操作被称作 &lt;code&gt;transpose&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def zipResult1 = [numbers1, numbers2].transpose()
println(&amp;quot;zip1 =&amp;gt; $zipResult1&amp;quot;)    //  [[1, 10], [2, 20], [3, 30]]

def zipResult2 = [numbers2, numbers1].transpose()
println(&amp;quot;zip2 =&amp;gt; $zipResult2&amp;quot;)  //  [[10, 1], [20, 2], [30, 3]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fold-操作:152af32176ddf9979e854df274b7c621&#34;&gt;Fold 操作&lt;/h3&gt;

&lt;p&gt;Fold 操作是给定一个初始值，然后集合中的第一个元素与初始值进行计算，计算结果再与集合中的下一个元素进行计算，以此类推。这种过程看起来很像 Reduce 操作，事实上 Reduce 操作可以看着 Fold 操作的一个特例，只是初始值为集合第一个元素和第二个元素的计算结果。Groovy 中的 Fold 操作被称为 &lt;code&gt;inject&lt;/code&gt;，只有从左开始的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def foldLeftResult = numbers1.inject(2) { n1, n2 -&amp;gt; n1 - n2 }
println(&amp;quot;foldLeft =&amp;gt; $foldLeftResult&amp;quot;)  //  -19
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filter-操作-1:152af32176ddf9979e854df274b7c621&#34;&gt;Filter 操作&lt;/h3&gt;

&lt;p&gt;Filter 操作通过对集合中的每一个元素应用一个返回值是布尔值的函数来获得一个返回值都是 &lt;code&gt;true&lt;/code&gt; 的新的集合。Groovy 中的 Filter 操作被称为 &lt;code&gt;findAll&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def filterResult = numbers1.findAll { it % 2 == 0 }
println(&amp;quot;filter =&amp;gt; $filterResult&amp;quot;)  //  [2, 4, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;foreach-操作-1:152af32176ddf9979e854df274b7c621&#34;&gt;ForEach 操作&lt;/h3&gt;

&lt;p&gt;ForEach 操作用于对集合进行遍历。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;numbers1.each { println(it) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parallel-操作-1:152af32176ddf9979e854df274b7c621&#34;&gt;Parallel 操作&lt;/h3&gt;

&lt;p&gt;Groovy 中的并发集合操作需要依赖于 &lt;code&gt;GPars&lt;/code&gt; 包，而且比较难用，所以不在本系列介绍范围中。&lt;/p&gt;

&lt;h2 id=&#34;scala:152af32176ddf9979e854df274b7c621&#34;&gt;Scala&lt;/h2&gt;

&lt;h3 id=&#34;map-操作-2:152af32176ddf9979e854df274b7c621&#34;&gt;Map 操作&lt;/h3&gt;

&lt;p&gt;Map 操作用于对集合中的每一个输入元素应用指定的函数从而得到另一种输出。输入类型和输出类型可以不一致。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val numbers1 = List(1, 2, 3, 4, 5, 6)	
val numbers2 = List(10, 20, 30)
val numbers3 = List(numbers1, numbers2)
val mapResult: List[Int] = numbers1.map(x =&amp;gt; x * x)
println(s&amp;quot;map =&amp;gt; $mapResult&amp;quot;) //  List(1, 4, 9, 16, 25, 36)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flatmap-操作-2:152af32176ddf9979e854df274b7c621&#34;&gt;FlatMap 操作&lt;/h3&gt;

&lt;p&gt;FlatMap 操作用于对输入元素进行抽出，得到扁平化的输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val flatMapResult: List[Int] = numbers3.flatMap(list =&amp;gt; list.map(x =&amp;gt; x * 10))
println(s&amp;quot;flatMap =&amp;gt; $flatMapResult&amp;quot;) //  List(10, 20, 30, 40, 50, 60, 100, 200, 300)       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只是想简单的抽出的话，可以直接使用更简单的 &lt;code&gt;flatten()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;println(s&amp;quot;flatten =&amp;gt; ${numbers3.flatten}&amp;quot;) //  List(1, 2, 3, 4, 5, 6, 10, 20, 30)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zip-操作-1:152af32176ddf9979e854df274b7c621&#34;&gt;Zip 操作&lt;/h3&gt;

&lt;p&gt;Zip 操作用于连接两个集合，新的集合以最短的集合为准。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val zipResult1: List[(Int, Int)] = numbers1.zip(numbers2)
println(s&amp;quot;zip1 =&amp;gt; $zipResult1&amp;quot;) //  List((1,10), (2,20), (3,30))

val zipResult2: List[(Int, Int)] = numbers2.zip(numbers1)
println(s&amp;quot;zip2 =&amp;gt; $zipResult2&amp;quot;) //  List((10,1), (20,2), (30,3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了 &lt;code&gt;zip()&lt;/code&gt; 方法外还有一个 &lt;code&gt;zipAll()&lt;/code&gt; 操作，该方法创建的集合以最长的集合为准，并且用指定值填充较短的集合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val zipResult3: List[(Int, Any)] = numbers1.zipAll(numbers2, -1, &#39;a&#39;)
println(s&amp;quot;zipAll =&amp;gt; $zipResult3&amp;quot;) //  List((1,10), (2,20), (3,30), (4,a), (5,a), (6,a))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上例子中当 &lt;code&gt;numbers1&lt;/code&gt; 较短时，新集合中就会以 &lt;code&gt;-1&lt;/code&gt; 填充不满足长度的位置，如果 &lt;code&gt;numbers2&lt;/code&gt; 较短，则以 &lt;code&gt;a&lt;/code&gt; 填充。&lt;/p&gt;

&lt;h3 id=&#34;reduce-操作-1:152af32176ddf9979e854df274b7c621&#34;&gt;Reduce 操作&lt;/h3&gt;

&lt;p&gt;Reduce 操作用于对集合中的每一个元素进行指定的计算从而得到计算结果。计算的过程是将第一个元素和第二个元素进行计算，得到的结果和第三个元素再进行计算，以此类推。&lt;/p&gt;

&lt;p&gt;Scala 有三个版本的 Reduce 操作，默认的版本第一个元素是集合的最左还是最右是不确定的，由 Scala 编译器自己决定。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val reduceResult = numbers1.reduce((n1, n2) =&amp;gt; n1 - n2)
println(s&amp;quot;reduce =&amp;gt; $reduceResult&amp;quot;) //  -19
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以通过 &lt;code&gt;reduceLeff()&lt;/code&gt; 指定从左开始为集合的第一个元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val reduceLeftResult = numbers1.reduceLeft((n1, n2) =&amp;gt; n1 - n2)
println(s&amp;quot;reduceLeft =&amp;gt; $reduceLeftResult&amp;quot;) //  -19
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样还有 &lt;code&gt;reduceRight()&lt;/code&gt; 的版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val reduceRightResult = numbers1.reduceRight((n1, n2) =&amp;gt; n1 - n2)
println(s&amp;quot;reduceRight =&amp;gt; $reduceRightResult&amp;quot;) //  -3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fold-操作-1:152af32176ddf9979e854df274b7c621&#34;&gt;Fold 操作&lt;/h3&gt;

&lt;p&gt;Fold 操作是给定一个初始值，然后集合中的第一个元素与初始值进行计算，计算结果再与集合中的下一个元素进行计算，以此类推。这种过程看起来很像 Reduce 操作，事实上 Reduce 操作可以看着 Fold 操作的一个特例，只是初始值为集合第一个元素和第二个元素的计算结果。&lt;/p&gt;

&lt;p&gt;Fold 操作也有从左和从右两个版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val foldLeftResult = numbers1.foldLeft(2)((n1, n2) =&amp;gt; n1 - n2)
println(s&amp;quot;foldLeft =&amp;gt; $foldLeftResult&amp;quot;) //  -19

val foldRightResult = numbers1.foldRight(0)((n1, n2) =&amp;gt; n1 - n2)
println(s&amp;quot;foldRight =&amp;gt; $foldRightResult&amp;quot;) //  -3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filter-操作-2:152af32176ddf9979e854df274b7c621&#34;&gt;Filter 操作&lt;/h3&gt;

&lt;p&gt;Filter 操作通过对集合中的每一个元素应用一个返回值是布尔值的函数来获得一个返回值都是 &lt;code&gt;true&lt;/code&gt; 的新的集合.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val filterResult = numbers1.filter(_ % 2 == 0)
println(s&amp;quot;filter =&amp;gt; $filterResult&amp;quot;) //  List(2, 4, 6)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;collect-操作-1:152af32176ddf9979e854df274b7c621&#34;&gt;Collect 操作&lt;/h3&gt;

&lt;p&gt;Collect 操作接收偏函数并返回偏函数处理的分组的结果集。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val collectResult = numbers1.collect(PartialFunction[Int, Option[Int]] {
	case x if x % 2 == 0 =&amp;gt; Some(x)
    case _ =&amp;gt; None
})
println(s&amp;quot;collect =&amp;gt; $collectResult&amp;quot;) //  List(None, Some(2), None, Some(4), None, Some(6))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;foreach-操作-2:152af32176ddf9979e854df274b7c621&#34;&gt;ForEach 操作&lt;/h3&gt;

&lt;p&gt;ForEach 操作用于对集合进行遍历。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;numbers1.foreach(println)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parallel-操作-2:152af32176ddf9979e854df274b7c621&#34;&gt;Parallel 操作&lt;/h3&gt;

&lt;p&gt;集合操作默认都是单线程的。但是可以使用 &lt;code&gt;par()&lt;/code&gt; 方法获得进行并发的流式操作的能力，并发使用的是 &lt;code&gt;ForkJoinPool&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;numbers1.par.foreach(println)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scala 中的并发流式操作和 Java 并不相同。虽然当前控制流中的操作是并发执行的，但是只有所有元素计算完毕后才会进行下一个控制流。且并发本身是不会被传递。而不像 Java 一个元素完成计算后就直接进入下一个控制流。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val parallelResult = numbers1.par.map((x) =&amp;gt; {
    println(s&amp;quot;stream first: $x on ${Thread.currentThread().getName}&amp;quot;)
    x
}).map((x) =&amp;gt; {
    println(s&amp;quot;stream second: $x on ${Thread.currentThread().getName}&amp;quot;)
    x
}).map((x) =&amp;gt; {
    println(s&amp;quot;stream third: $x on ${Thread.currentThread().getName}&amp;quot;)
    x
})
println(parallelResult)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;kotlin:152af32176ddf9979e854df274b7c621&#34;&gt;Kotlin&lt;/h2&gt;

&lt;h3 id=&#34;map-操作-3:152af32176ddf9979e854df274b7c621&#34;&gt;Map 操作&lt;/h3&gt;

&lt;p&gt;Map 操作用于对集合中的每一个输入元素应用指定的函数从而得到另一种输出。输入类型和输出类型可以不一致。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val numbers1 = listOf(1, 2, 3, 4, 5, 6)
val numbers2 = listOf(10, 20, 30)
val numbers3 = listOf(numbers1, numbers2)
//  Map
val mapResult: List&amp;lt;Int&amp;gt; = numbers1.map { it * it }
println(&amp;quot;map =&amp;gt; $mapResult&amp;quot;)    //  [1, 4, 9, 16, 25, 36]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flatmap-操作-3:152af32176ddf9979e854df274b7c621&#34;&gt;FlatMap 操作&lt;/h3&gt;

&lt;p&gt;FlatMap 操作用于对输入元素进行抽出，得到扁平化的输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val flatMapResult: List&amp;lt;Int&amp;gt; = numbers3.flatMap { it.map { it * 10 } }
println(&amp;quot;flatMap =&amp;gt; $flatMapResult&amp;quot;) //  [10, 20, 30, 40, 50, 60, 100, 200, 300]         
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只是想简单的抽出的话，可以直接使用更简单的 &lt;code&gt;flatten()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;println(&amp;quot;flatten =&amp;gt; ${numbers3.flatten()}&amp;quot;) //  [1, 2, 3, 4, 5, 6, 10, 20, 30]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zip-操作-2:152af32176ddf9979e854df274b7c621&#34;&gt;Zip 操作&lt;/h3&gt;

&lt;p&gt;Zip 操作用于连接两个集合，新的集合以最短的集合为准。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val zipResult1: List&amp;lt;Pair&amp;lt;Int, Int&amp;gt;&amp;gt; = numbers1.zip(numbers2)
println(&amp;quot;zip1 =&amp;gt; $zipResult1&amp;quot;)  //  [(1, 10), (2, 20), (3, 30)]

val zipResult2: List&amp;lt;Pair&amp;lt;Int, Int&amp;gt;&amp;gt; = numbers2.zip(numbers1)
println(&amp;quot;zip2 =&amp;gt; $zipResult2&amp;quot;)  //  [(10, 1), (20, 2), (30, 3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reduce-操作-2:152af32176ddf9979e854df274b7c621&#34;&gt;Reduce 操作&lt;/h3&gt;

&lt;p&gt;Reduce 操作用于对集合中的每一个元素进行指定的计算从而得到计算结果。计算的过程是将第一个元素和第二个元素进行计算，得到的结果和第三个元素再进行计算，以此类推。&lt;/p&gt;

&lt;p&gt;Kotlin 有两个个版本的 Reduce 操作，默认的版本从左开始。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val reduceLeftResult = numbers1.reduce { n1, n2 -&amp;gt; n1 - n2 }
println(&amp;quot;reduce =&amp;gt; $reduceLeftResult&amp;quot;)  //  -19

val reduceRightResult = numbers1.reduceRight { n1, n2 -&amp;gt; n1 - n2 }
println(&amp;quot;reduceRight =&amp;gt; $reduceRightResult&amp;quot;)    //  -3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fold-操作-2:152af32176ddf9979e854df274b7c621&#34;&gt;Fold 操作&lt;/h3&gt;

&lt;p&gt;Fold 操作是给定一个初始值，然后集合中的第一个元素与初始值进行计算，计算结果再与集合中的下一个元素进行计算，以此类推。这种过程看起来很像 Reduce 操作，事实上 Reduce 操作可以看着 Fold 操作的一个特例，只是初始值为集合第一个元素和第二个元素的计算结果。&lt;/p&gt;

&lt;p&gt;Fold 操作也有从左和从右两个版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val foldLeftResult = numbers1.fold(2) { n1, n2 -&amp;gt; n1 - n2 }
println(&amp;quot;foldLeft =&amp;gt; $foldLeftResult&amp;quot;)  //  -19

val foldRightResult = numbers1.foldRight(0) { n1, n2 -&amp;gt; n1 - n2 }
println(&amp;quot;foldRight =&amp;gt; $foldRightResult&amp;quot;)    //  -3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filter-操作-3:152af32176ddf9979e854df274b7c621&#34;&gt;Filter 操作&lt;/h3&gt;

&lt;p&gt;Filter 操作通过对集合中的每一个元素应用一个返回值是布尔值的函数来获得一个返回值都是 &lt;code&gt;true&lt;/code&gt; 的新的集合.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val filterResult = numbers1.filter { it % 2 == 0 }
println(&amp;quot;filter =&amp;gt; $filterResult&amp;quot;)  //  [2, 4, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;foreach-操作-3:152af32176ddf9979e854df274b7c621&#34;&gt;ForEach 操作&lt;/h3&gt;

&lt;p&gt;ForEach 操作用于对集合进行遍历。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;numbers1.forEach { println(it) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parallel-操作-3:152af32176ddf9979e854df274b7c621&#34;&gt;Parallel 操作&lt;/h3&gt;

&lt;p&gt;Kotlin 目前并没有并行集合，不过官方计划在将来实现。&lt;/p&gt;

&lt;h2 id=&#34;总结:152af32176ddf9979e854df274b7c621&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Java 1.8 和 Scala 支持并行集合，但是效果完全不同&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;项目源码见 &lt;a href=&#34;https://github.com/SidneyXu/JGSK&#34;&gt;JGSK/_35_collection_function&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - 16.方法 vs Lambda 表达式 vs 闭包 - Kotlin 篇</title>
      <link>http://git.bookislife.com/post/2015/jgsk-16-method-lambda-closure-kotlin/</link>
      <pubDate>Mon, 14 Dec 2015 16:05:01 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-16-method-lambda-closure-kotlin/</guid>
      <description>

&lt;h2 id=&#34;kotlin-篇:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;Kotlin 篇&lt;/h2&gt;

&lt;h3 id=&#34;方法:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;方法&lt;/h3&gt;

&lt;h4 id=&#34;定义方法:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;定义方法&lt;/h4&gt;

&lt;p&gt;完整的 Kotlin 方法定义语法为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[访问控制符] fun 方法名(参数列表) [:返回值类型] {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kotlin 可以省略变量定义的类型声明，但是在定义参数列表和定义返回值类型时则必须明确指定类型。&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun add(x: Int, y: Int): Int {
    return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kotlin 只有成员方法，没有静态方法，但是可以通过单例来实现静态方法的功能，具体内容见 Object 章节。&lt;/p&gt;

&lt;h4 id=&#34;varargs:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;Varargs&lt;/h4&gt;

&lt;p&gt;Kotlin 使用 &lt;code&gt;vararg&lt;/code&gt; 修饰参数来表示变参。&lt;/p&gt;

&lt;p&gt;声明一个变参方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Calculator {
    fun sum(vararg n: Int) {
        println(n.sum())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用该方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val calculator = Calculator()
calculator.sum(1, 2, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;参数默认值:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;参数默认值&lt;/h4&gt;

&lt;p&gt;Kotlin 同 Scala 一样支持参数默认值，但是一旦使用参数默认值时，参数列表的最后一个或最后几个参数都必须有默认值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun say(name: String, word: String = &amp;quot;Hello&amp;quot;) {
    println(&amp;quot;$word $name&amp;quot;)
}

say(&amp;quot;Peter&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;返回值:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;Kotlin  同 Java 一样不会必须使用 &lt;code&gt;return&lt;/code&gt; 语句来返回执行结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun add(x: Int, y: Int): Int {
    return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;方法嵌套:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;方法嵌套&lt;/h4&gt;

&lt;p&gt;Kotlin 支持方法嵌套，即一个方法可以定义在另一个方法中，且内层方法可以访问外层方法的成员。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun testMethod() {
    var x = 1
    fun add(y: Int): Int {
        return x + y
    }
    println(add(100))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lambda-表达式:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;Lambda 表达式&lt;/h3&gt;

&lt;p&gt;同 Scala 一样，闭包和 Lambda 也合在一节讲。&lt;/p&gt;

&lt;h3 id=&#34;闭包:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;闭包&lt;/h3&gt;

&lt;p&gt;同 Scala 一样，Kotlin 也支持闭包，但是写法有些不同。&lt;/p&gt;

&lt;h4 id=&#34;创建一个闭包:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;创建一个闭包&lt;/h4&gt;

&lt;p&gt;由于闭包是个代码块，所以最简单的闭包形式如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;{ -&amp;gt; println(&amp;quot;foo&amp;quot;) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;字面量:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;字面量&lt;/h4&gt;

&lt;p&gt;闭包可以存储在一个变量中，这一点是实现函数是一等公民的重要手段。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val excite = { word: String -&amp;gt;
    &amp;quot;$word!!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;调用闭包:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;调用闭包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;excite(&amp;quot;Java&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;excite.invoke(&amp;quot;Kotlin&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;多参数:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;多参数&lt;/h4&gt;

&lt;p&gt;同 Scala 一样，Kotlin 中闭包的参数不能有默认值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val plus = { x: Int, y: Int -&amp;gt;
    println(&amp;quot;$x plus $y is ${x + y}&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;it:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;it&lt;/h4&gt;

&lt;p&gt;同 Groovy 一样闭包只有一个参数时可以使用 &lt;code&gt;it&lt;/code&gt; 直接指代该参数而不用预先声明参数列表。但是不像 Groovy 那么方便，Kotlin 中这一特性仅能用作传递作为参数的闭包中而不能用在定义闭包时。&lt;/p&gt;

&lt;p&gt;以下闭包作为参数传递给方法 &lt;code&gt;filter&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val ints = arrayOf(1, 2, 3)
ints.filter {
    it &amp;gt; 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下定义闭包时指定 &lt;code&gt;it&lt;/code&gt; 是非法的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val greeting = { -&amp;gt; println(it) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;varargs-1:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;Varargs&lt;/h4&gt;

&lt;p&gt;Kotlin 中闭包不支持变参&lt;/p&gt;

&lt;h4 id=&#34;闭包作为参数:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;闭包作为参数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun max(numbers: Array&amp;lt;Int&amp;gt;, s: (Array&amp;lt;Int&amp;gt;) -&amp;gt; Int): Int {
    return s.invoke(numbers)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入闭包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val maxValue = max(arrayOf(3, 10, 2, 1, 40)) {
    it.max()!!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;自执行闭包:699a1f3ac3668a624b6c4fa0a441f7e2&#34;&gt;自执行闭包&lt;/h4&gt;

&lt;p&gt;自执行闭包即定义闭包的同时直接执行闭包，一般用于初始化上下文环境，Javascript 中常使用这种方法来初始化文档。&lt;/p&gt;

&lt;p&gt;定义一个自执行的闭包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;{ x: Int, y: Int -&amp;gt;
    println(&amp;quot;$x plus $y is ${x + y}&amp;quot;)
}(1, 3)    //  1 plus 3 is 4
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - 16.方法 vs Lambda 表达式 vs 闭包 - Scala 篇</title>
      <link>http://git.bookislife.com/post/2015/jgsk-16-method-lambda-closure-scala/</link>
      <pubDate>Mon, 14 Dec 2015 14:59:46 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-16-method-lambda-closure-scala/</guid>
      <description>

&lt;h2 id=&#34;scala-篇:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;Scala 篇&lt;/h2&gt;

&lt;h3 id=&#34;方法:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;方法&lt;/h3&gt;

&lt;h4 id=&#34;定义方法:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;定义方法&lt;/h4&gt;

&lt;p&gt;完整的 Scala 方法定义语法为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[访问控制符] def 方法名(参数列表) [:返回值类型] [=] {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scala 可以省略变量定义的类型声明和返回值类型，但是在定义参数列表时则必须明确指定类型。&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def add(x: Int, y: Int): Int = {
  x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scala 只有成员方法，没有静态方法，但是可以通过单例来实现静态方法的功能，具体内容见 Object 章节。&lt;/p&gt;

&lt;h4 id=&#34;参数列表:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;参数列表&lt;/h4&gt;

&lt;p&gt;Scala 中参数列表必须明确指定参数类型。如果一个方法没有参数列表时，可以省略小括号，但是调用时也不能加上小括号。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//  没有小括号
def info(): Unit = {
  println(&amp;quot;This is a class called Calculator.&amp;quot;)
}
println(info())

//  有小括号
def info2: Unit = {
  println(&amp;quot;This is a class called Calculator.&amp;quot;)
}
println(info)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;varargs:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;Varargs&lt;/h4&gt;

&lt;p&gt;Scala 使用 &lt;code&gt;参数类型*&lt;/code&gt; 表示变参。&lt;/p&gt;

&lt;p&gt;声明一个变参方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Calculator {
  def sum(n: Int*) {
    println(n.sum)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用该方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val calculator = new Calculator
calculator.sum(1, 2, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_5:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;_*&lt;/h4&gt;

&lt;p&gt;如果希望将一个 Sequence 作为参数传入上一节的 &lt;code&gt;sum()&lt;/code&gt; 方法的话编辑器会报参数不匹配。此时可以使用 &lt;code&gt;_*&lt;/code&gt; 操作符，&lt;code&gt;_*&lt;/code&gt; 可以将一个 Sequence 展开为多个参数进行传递。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;calculator.sum(1 to 3: _*)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;参数默认值:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;参数默认值&lt;/h4&gt;

&lt;p&gt;Scala 同 Groovy 一样支持参数默认值，但是一旦使用参数默认值时，参数列表的最后一个或最后几个参数都必须有默认值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def say(name: String, word: String = &amp;quot;Hello&amp;quot;): Unit = {
  println(s&amp;quot;$word $name&amp;quot;)
}

say(&amp;quot;Peter&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;返回值:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;Scala 中总是会返回方法内部的最后一个语句的执行结果，所以无需 &lt;code&gt;return&lt;/code&gt; 语句。如果没有返回值的话需要声明返回值类型为 &lt;code&gt;Unit&lt;/code&gt;，并此时可以省略 &lt;code&gt;:Unit=&lt;/code&gt;。如果方法没有递归的话返回值类型也可以省略，但是必须使用 &lt;code&gt;=&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;默认返回最后一行的执行结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def add(x: Int, y: Int): Int = {
  x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无返回值的情况&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def echo(): Unit = {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无返回值时可以简写为以下形式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def echo() = {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;方法嵌套:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;方法嵌套&lt;/h4&gt;

&lt;p&gt;Scala 支持方法嵌套，即一个方法可以定义在另一个方法中，且内层方法可以访问外层方法的成员。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def testMethod(): Unit = {
  var x = 1
  def add(y: Int): Int = {
    x + y
  }
  println(add(100))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lambda-表达式:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;Lambda 表达式&lt;/h3&gt;

&lt;p&gt;同 Groovy 一样，闭包和 Lambda 也合在一节讲。&lt;/p&gt;

&lt;h3 id=&#34;闭包:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;闭包&lt;/h3&gt;

&lt;p&gt;同 Groovy 一样，Scala 也支持闭包，但是写法有些不同。&lt;/p&gt;

&lt;h4 id=&#34;创建一个闭包:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;创建一个闭包&lt;/h4&gt;

&lt;p&gt;由于闭包是个代码块，所以最简单的闭包形式如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;() =&amp;gt; println(&amp;quot;foo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;字面量:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;字面量&lt;/h4&gt;

&lt;p&gt;闭包可以存储在一个变量中，这一点是实现函数是一等公民的重要手段。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val excite = (word: String) =&amp;gt;
  s&amp;quot;$word!!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;调用闭包:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;调用闭包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;excite(&amp;quot;Java&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;excite.apply(&amp;quot;Scala&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;多参数:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;多参数&lt;/h4&gt;

&lt;p&gt;闭包的参数可以和方法的参数一样拥有多个参数，但是同 Groovy 不一样，Scala 中闭包的参数不能有默认值，且参数列表为多个时必须将参数包裹在小括号内。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val plus =  (x: Int, y: Int) =&amp;gt;
  println(s&amp;quot;$x plus $y is ${x + y}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;toc_15:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;_&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;_&lt;/code&gt; 是个占位符，当闭包只有一个参数时，使用 &lt;code&gt;_&lt;/code&gt; 可以直接指代该参数而不用预先声明参数列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val greeting = &amp;quot;Hello,  &amp;quot; + _
println(greeting(&amp;quot;Peter&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;varargs-1:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;Varargs&lt;/h4&gt;

&lt;p&gt;Scala 中闭包不支持变参&lt;/p&gt;

&lt;h4 id=&#34;闭包作为参数:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;闭包作为参数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def max(numbers: Array[Int], s: (Array[Int]) =&amp;gt; Int): Unit = {
  s.apply(numbers)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入闭包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val maxValue = max(Array(3, 10, 2, 1, 40), (numbers) =&amp;gt; {
  numbers.max
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用如下方式进行简化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def max2(numbers: Array[Int])(s: (Array[Int]) =&amp;gt; Int): Unit = {
  s.apply(numbers)
}

maxValue = max2(Array(3, 10, 2, 1, 40)) { numbers =&amp;gt;
  numbers.max
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;自执行闭包:9832eeffc44c8a1200d7b689bf82f929&#34;&gt;自执行闭包&lt;/h4&gt;

&lt;p&gt;自执行闭包即定义闭包的同时直接执行闭包，一般用于初始化上下文环境，Javascript 中常使用这种方法来初始化文档。&lt;/p&gt;

&lt;p&gt;定义一个自执行的闭包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;((x: Int, y: Int) =&amp;gt; {
  println(s&amp;quot;$x plus $y is ${x + y}&amp;quot;)
})(1, 3)    //  1 plus 3 is 4
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - 16.方法 vs Lambda 表达式 vs 闭包 - Groovy 篇</title>
      <link>http://git.bookislife.com/post/2015/jgsk-16-method-lambda-closure-groovy/</link>
      <pubDate>Mon, 14 Dec 2015 14:37:28 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-16-method-lambda-closure-groovy/</guid>
      <description>

&lt;h2 id=&#34;groovy-篇:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;Groovy 篇&lt;/h2&gt;

&lt;h3 id=&#34;方法:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;方法&lt;/h3&gt;

&lt;h4 id=&#34;定义方法:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;定义方法&lt;/h4&gt;

&lt;p&gt;完整的 Groovy 方法定义语法为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[访问控制符] [static] def 方法名(参数列表)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Groovy 也和 Java 一样有成员方法和静态方法之分。&lt;/p&gt;

&lt;p&gt;成员方法表示类的对象的一种行为，声明时没有关键字 &lt;code&gt;static&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def add(x, y) {
    x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;静态方法使用关键字 &lt;code&gt;static&lt;/code&gt; 声明，属于类的行为，或称作类对象的行为，因此调用时无需创建任何对象。&lt;code&gt;main()&lt;/code&gt; 方法就是最常见的静态方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;static def main(String[] args) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;varargs:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;Varargs&lt;/h4&gt;

&lt;p&gt;Groovy 表示变参的方式与 Java 一样，且变参也只能出现在参数列表的最后一个。&lt;/p&gt;

&lt;p&gt;声明一个变参方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;class Calculator {
    def sum(int ... n) {
        print(n.sum())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用该方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def calculator = new Calculator()
calculator.sum(1, 2, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;参数默认值:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;参数默认值&lt;/h4&gt;

&lt;p&gt;Groovy 支持参数默认值，但是一旦使用参数默认值时，参数列表的最后一个或最后几个参数都必须有默认值，即 &lt;code&gt;def foo(x, y, z =&amp;quot;bar&amp;quot;)&lt;/code&gt; 和 &lt;code&gt;def foo(x, y = &amp;quot;bar&amp;quot;, z = &amp;quot;bar&amp;quot;)&lt;/code&gt; 都是合法的，但是 &lt;code&gt;def foo(x, y = &amp;quot;bar&amp;quot;, z)&lt;/code&gt; 则是非法的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;static def say(name, word = &amp;quot;Hello&amp;quot;) {
    println(&amp;quot;$word $name&amp;quot;)
}

say(&amp;quot;Peter&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;返回值:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;Groovy 中由动态类型的存在，所以可以不声明返回值类型。并且在 Groovy 中方法的最后一个语句的执行结果总是回被返回（也适用于无返回值的时候），所以也无需 &lt;code&gt;return&lt;/code&gt; 语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def add(x, y) {
    x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lambda-表达式:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;Lambda 表达式&lt;/h3&gt;

&lt;p&gt;Groovy 目前还不支持 Java 1.8 的特性，所以 Java 中的 Lambda 表达式和对应的函数式接口无法在 Groovy 中直接使用。但是 Groovy 本身支持闭包，且闭包就是以 Lambda 表达式的形式存在的，所以闭包和 Lambda 合在一节讲。&lt;/p&gt;

&lt;h3 id=&#34;闭包:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;闭包&lt;/h3&gt;

&lt;h4 id=&#34;概念:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;概念&lt;/h4&gt;

&lt;p&gt;闭包是一种带有自由变量的代码块，其最显著的特性就是能够扩大局部变量的生命周期。与 Java 不同，Groovy 支持真正的闭包。&lt;/p&gt;

&lt;h4 id=&#34;创建一个闭包:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;创建一个闭包&lt;/h4&gt;

&lt;p&gt;由于闭包是个代码块，所以一般意义上最简单的闭包形式如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;{ println(&amp;quot;foo&amp;quot;) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过由于 Java 的普通代码块也是这样的形式，所以为了避免混淆，以上闭包必须写成如下形式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;{ -&amp;gt; println(&amp;quot;foo&amp;quot;) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;综上所述，闭包的语法为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ 参数列表 -&amp;gt; 执行语句 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;{ x, y -&amp;gt;
    println &amp;quot;$x plus $y is ${x + y}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Groovy 中定义闭包实际是定义了一个继承自 &lt;code&gt;Closure&lt;/code&gt; 类的匿名内部类，执行闭包实际是执行该类的实例的方法。这一点与 Java 非常相似。&lt;/p&gt;

&lt;h4 id=&#34;字面量:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;字面量&lt;/h4&gt;

&lt;p&gt;闭包可以存储在一个变量中，这一点是实现函数是一等公民的重要手段。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def excite = { word -&amp;gt;
    &amp;quot;$word!!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;调用闭包:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;调用闭包&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;excite(&amp;quot;Java&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;excite.call(&amp;quot;Groovy&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;多参数:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;多参数&lt;/h4&gt;

&lt;p&gt;闭包的参数可以和方法的参数一样拥有多个参数及默认值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def plus = { int x, int y = 1 -&amp;gt;
    println &amp;quot;$x plus $y is ${x + y}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;it:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;it&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;it&lt;/code&gt; 是个隐式参数，当闭包只有一个参数时，使用 &lt;code&gt;it&lt;/code&gt; 可以直接指代该参数而不用预先声明参数列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def greeting = { &amp;quot;Hello, $it!&amp;quot; }
println(greeting(&amp;quot;Peter&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;varargs-1:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;Varargs&lt;/h4&gt;

&lt;p&gt;闭包也支持变参&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def contact = { String... args -&amp;gt; args.join(&#39;,&#39;) }
println(contact(&amp;quot;Java&amp;quot;, &amp;quot;Groovy&amp;quot;, &amp;quot;Scala&amp;quot;, &amp;quot;Kotlin&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;闭包作为参数:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;闭包作为参数&lt;/h4&gt;

&lt;p&gt;由于闭包本质是 &lt;code&gt;Closure&lt;/code&gt; 的子类，所以可以使用 &lt;code&gt;Closure&lt;/code&gt; 作为参数的类型接收一个闭包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;static def max(numbers, Closure&amp;lt;Integer&amp;gt; closure) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进一步简化后&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;static def max(numbers, cls) {
    cls(numbers)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入闭包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def maxValue = max([3, 10, 2, 1, 40]) {
    def list = it as List&amp;lt;Integer&amp;gt;
    list.max()
}
assert maxValue == 40
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;自执行闭包:f1f5cc17fac8fa7af8b8d7379224a9db&#34;&gt;自执行闭包&lt;/h4&gt;

&lt;p&gt;自执行闭包即定义闭包的同时直接执行闭包，一般用于初始化上下文环境，Javascript 中常使用这种方法来初始化文档。&lt;/p&gt;

&lt;p&gt;定义一个自执行的闭包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;{ int x, int y -&amp;gt;
    println &amp;quot;$x plus $y is ${x + y}&amp;quot;
}(1, 3) //  1 plus 3 is 4
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - 16.方法 vsLambda 表达式 vs 闭包 - Java 篇</title>
      <link>http://git.bookislife.com/post/2015/jgsk-16-method-lambda-closure-java/</link>
      <pubDate>Fri, 11 Dec 2015 12:13:45 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-16-method-lambda-closure-java/</guid>
      <description>

&lt;h2 id=&#34;java-篇:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;Java 篇&lt;/h2&gt;

&lt;h3 id=&#34;方法:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;方法&lt;/h3&gt;

&lt;h4 id=&#34;定义方法:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;定义方法&lt;/h4&gt;

&lt;p&gt;完整的 Java 定义语法为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[访问控制符] [static] [返回值类型] 方法名(参数列表)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 中方法必须声明在类的内部，且被分为成员方法和静态方法。&lt;/p&gt;

&lt;p&gt;成员方法表示类的对象的一种行为，声明时没有关键字 &lt;code&gt;static&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int add(int x, int y) {
    return x + y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;静态方法使用关键字 &lt;code&gt;static&lt;/code&gt; 声明，属于类的行为，或称作类对象的行为，因此调用时无需创建任何对象。&lt;code&gt;main()&lt;/code&gt; 方法就是最常见的静态方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;varargs:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;Varargs&lt;/h4&gt;

&lt;p&gt;Varargs 即参数长度不确定，简称变参。Java 使用符号 &lt;code&gt;...&lt;/code&gt; 表示变参，但是变参只能出现在参数列表的最后一个，即 &lt;code&gt;sum(int x, int y, int...n)&lt;/code&gt; 是合法的，但 &lt;code&gt;sum(int x, int...n, int y)&lt;/code&gt; 或 &lt;code&gt;sum(int...n, int x, int y)&lt;/code&gt; 都是非法的。&lt;/p&gt;

&lt;p&gt;声明一个变参方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Calculator {
    public void sum(int... n) {
        int result = 0;
        for (int i : n) {
            result += i;
        }
        System.out.println(result);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用该方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Calculator calculator = new Calculator();
calculator.sum(1, 2, 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;参数默认值:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;参数默认值&lt;/h4&gt;

&lt;p&gt;Java 不支持参数默认值，所以调用时必须为每一个参数赋值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static void say(String name, String word) {
    if (word == null) {
        System.out.println(word + &amp;quot; &amp;quot; + name);
    }
}

say(&amp;quot;Peter&amp;quot;, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;返回值:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;Java 中方法除非返回值类型声明为 &lt;code&gt;void&lt;/code&gt; 表示没有返回值，否则必须在方法中调用 &lt;code&gt;return&lt;/code&gt; 语句返回到调用处。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int add(int x, int y) {
    return x + y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lambda-表达式:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;Lambda 表达式&lt;/h3&gt;

&lt;p&gt;所谓的 Lambda 表达式其实就是一个匿名函数。Java 中由于不能有独立于类的函数存在，所以匿名函数一直都是通过定义一个包含抽象方法的匿名内部类来实现的。而 Java 1.8 后引入的 Lambda 表达式其实只是原来实现方式的一种语法糖。&lt;/p&gt;

&lt;p&gt;Java 1.8 以前使用匿名内部类的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(final ActionEvent e) {
        System.out.println(&amp;quot;Perform Click&amp;quot;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java 1.8 使用 Lambda 的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;button.addActionListener(e -&amp;gt; System.out.println(&amp;quot;Perform Click&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sam-类型与函数接口:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;SAM 类型与函数接口&lt;/h4&gt;

&lt;p&gt;SAM （Single Abstract Method）是有且仅有一个抽象方法的类型，该类型可以是抽象类也可以是接口。&lt;/p&gt;

&lt;p&gt;函数接口是 Java 1.8 中引入的概念，其实就是一个普通的接口，但是该接口中有且仅有一个抽象方法。所以函数接口就是一种  SAM 类型。&lt;/p&gt;

&lt;p&gt;Java 中的 Lambda 表达式就是通过函数接口来实现的，所以其与 1.8 以前使用匿名内部类的最大区别就是匿名内部类中可以定义多个抽象方法，而要使用 Lambda 表达式则只能定义一个抽象方法。&lt;/p&gt;

&lt;p&gt;定义一个函数接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
interface Excite {
    String accept(String from);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上使用了注解 &lt;code&gt;@FunctionalInterface&lt;/code&gt;，在 Java 1.8 的初期版本这个注解用于标示一个接口为函数接口，但在现在的版本已经可以省略这个注解了。&lt;/p&gt;

&lt;h4 id=&#34;使用-lambda-表达式:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;使用 Lambda 表达式&lt;/h4&gt;

&lt;p&gt;Lambda 表达式的基本语法为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;(参数列表) -&amp;gt; {执行语句}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果执行语句只有一句的话可以省略包裹其的花括号&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Excite excite = (word) -&amp;gt; word + &amp;quot;!!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们可以很方便的调用这个接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;excite.accept(&amp;quot;Java&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 Lambda 语句只有一个语句且只有一个参数，且该语句调用的是一个静态方法，则可以使用符号 &lt;code&gt;::&lt;/code&gt; 进一步缩减代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Excite hello = (w) -&amp;gt; String.valueOf(w);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上等同于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Excite hello = String::valueOf;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 Lambda 语句只有一个语句，且该语句为使用类的无参构造方法创建类的实例，则也可以使用符号 &lt;code&gt;::&lt;/code&gt; 进一步缩减代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Excite hello = (w) -&amp;gt; new Word();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上等同于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Excite hello = Word::new;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;多个参数:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;多个参数&lt;/h4&gt;

&lt;p&gt;函数接口也可以接收多个参数，这些参数可以为泛型而不是具体类型，实际上使用泛型的函数接口更为常见&lt;/p&gt;

&lt;p&gt;以下定义了一个接收两个参数 &lt;code&gt;F1&lt;/code&gt; 和 &lt;code&gt;F2&lt;/code&gt;，返回 &lt;code&gt;T&lt;/code&gt; 类型的接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Convert&amp;lt;F1, F2, T&amp;gt; {
    T convert(F1 from1, F2 from2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用该接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Convert&amp;lt;Integer, Integer, String&amp;gt; convert = (x, y) -&amp;gt; {
    int result = x + y;
    return x + &amp;quot; plus &amp;quot; + y + &amp;quot; is &amp;quot; + result;
};
System.out.println(convert.convert(1, 2));  //  1 plus 2 is 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;变参:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;变参&lt;/h4&gt;

&lt;p&gt;在 Lambda 表达式中也一样可以使用变参&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;p&gt;定义一个含有变参的接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Contact&amp;lt;F, T&amp;gt; {
    T accept(F... from);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用该接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Contact&amp;lt;String, String&amp;gt; contact = (args) -&amp;gt; String.join(&amp;quot;,&amp;quot;, args);
contact.accept(&amp;quot;Java&amp;quot;, &amp;quot;Groovy&amp;quot;, &amp;quot;Scala&amp;quot;, &amp;quot;Kotlin&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;内置函数接口:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;内置函数接口&lt;/h4&gt;

&lt;p&gt;通过以上例子我们可以看到要想使用 Lambda 表达式我们必须先定义一个函数接口，这样用法太过麻烦。所以 Java 提供了一些内置的函数接口供我们调用.&lt;/p&gt;

&lt;h5 id=&#34;predicate:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;Predicate&lt;/h5&gt;

&lt;p&gt;Predicate 接口用于接收一个参数并返回 Boolean 值，主要用于处理逻辑动词。该接口还有一个默认方法 &lt;code&gt;negate()&lt;/code&gt; 用于进行逻辑取反。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Predicate&amp;lt;String&amp;gt; predicate = (s) -&amp;gt; s.length() &amp;gt; 0;
assert predicate.test(&amp;quot;foo&amp;quot;);
assert !predicate.negate().test(&amp;quot;foo&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;function:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;Function&lt;/h5&gt;

&lt;p&gt;Function 接口接收一个参数并返回单一结果，主要用于进行类型转换等功能。该接口也提供了一个 &lt;code&gt;andThen()&lt;/code&gt; 方法用于执行链式操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Function&amp;lt;String, Integer&amp;gt; toInteger = Integer::valueOf;
Function&amp;lt;String, String&amp;gt; backToString = toInteger.andThen(String::valueOf);
assert toInteger.apply(&amp;quot;123&amp;quot;) == 123;
assert backToString.apply(&amp;quot;123&amp;quot;).equals(&amp;quot;123&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;supplier:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;Supplier&lt;/h5&gt;

&lt;p&gt;Supplier 接口没有参数，但是会返回单一结果，可以用于实现工厂方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Supplier&amp;lt;Calculator&amp;gt; calculatorSupplier = Calculator::new;
assert calculatorSupplier.get().add(1, 2) == 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;consumer:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;Consumer&lt;/h5&gt;

&lt;p&gt;Consumer 接口接收一个参数，没有返回值，用于对传入的参数进行某些处理。该接口也提供了 &lt;code&gt;andThen()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Consumer&amp;lt;Person&amp;gt; calculatorConsumer = (p) -&amp;gt;
        System.out.println(&amp;quot;The name is &amp;quot; + p.getName());
calculatorConsumer.accept(new Person(&amp;quot;Peter&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;comparator:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;Comparator&lt;/h5&gt;

&lt;p&gt;Comparator 接口接收两个参数，返回 int 值，用于进行排序操作。该接口提供了 &lt;code&gt;reversed()&lt;/code&gt; 方法进行反序排列。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Comparator&amp;lt;Person&amp;gt; comparator = (p1, p2) -&amp;gt;
        p1.getAge().compareTo(p2.getAge());
Person john = new Person(&amp;quot;John&amp;quot;, 20);
Person alice = new Person(&amp;quot;Alice&amp;quot;, 18);

assert comparator.compare(john, alice) &amp;gt; 0;
assert comparator.reversed().compare(john, alice) &amp;lt; 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;函数接口作为参数:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;函数接口作为参数&lt;/h4&gt;

&lt;p&gt;函数接口也可以作为参数来使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static int max(int[] arr, Function&amp;lt;int[], Integer&amp;gt; integerFunction) {
    return integerFunction.apply(arr);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用该接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int maxValue = max(new int[]{3, 10, 2, 40}, (s) -&amp;gt; {
    int max = -1;
    for (int n : s) {
        if (max &amp;lt; n) max = n;
    }
    return max;
});
assert maxValue == 40;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;闭包:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;闭包&lt;/h3&gt;

&lt;h4 id=&#34;概念:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;概念&lt;/h4&gt;

&lt;p&gt;闭包是一种带有自由变量的代码块，其最显著的特性就是能够扩大局部变量的生命周期。&lt;/p&gt;

&lt;h4 id=&#34;闭包与-lambda-表达式:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;闭包与 Lambda 表达式&lt;/h4&gt;

&lt;p&gt;闭包与 Lambda 表达式的概念非常容易让人混淆，但两者确实是不同的东西。Lambda 表达式是匿名函数，而闭包则是实现函数是第一类对象的一种手段。两者的直接关系是 Lambda 表达式可以作为闭包的一种表现形式，但闭包除了 Lambda 表达式也可以表现为多种形式，这也就是在各种语言中闭包的写法会有很多差别的原因。&lt;/p&gt;

&lt;h4 id=&#34;闭包与方法:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;闭包与方法&lt;/h4&gt;

&lt;p&gt;闭包和方法的最大区别是方法执行完毕后其内部的变量便会被释放，而闭包不会。闭包可以进行嵌套，而方法不行。&lt;/p&gt;

&lt;h4 id=&#34;java-中的闭包:d088721b895d71ec0f6e0bbf96ee32a0&#34;&gt;Java 中的闭包&lt;/h4&gt;

&lt;p&gt;Java 中和闭包相近的概念就是匿名类以及本章所说的 Lambda 表达式。但是这两种都不是真正意义上的闭包。&lt;/p&gt;

&lt;p&gt;先看一个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Excite {
    String accept(String from);
}
private static Excite excite(String s) {
  Excite e = from -&amp;gt; {
    from = &amp;quot;from=&amp;quot; + from;
    return from + &amp;quot;,&amp;quot; + s;
  };
  return e;
}
Excite excite = excite(&amp;quot;hello&amp;quot;);
System.out.println(excite.accept(&amp;quot;world&amp;quot;)); //  from=world,hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上例子中 &lt;code&gt;e&lt;/code&gt; 为 Lambda 表达式，其定义在 &lt;code&gt;excite()&lt;/code&gt; 方法中并且访问了该方法的参数列表。按照生命周期，&lt;code&gt;excite()&lt;/code&gt; 的参数 &lt;code&gt;s&lt;/code&gt; 应该在方法被调用后就自动释放，即 &lt;code&gt;Excite excite = excite(&amp;quot;hello&amp;quot;)&lt;/code&gt; 调用后就不存在参数 &lt;code&gt;hello&lt;/code&gt; 了，但实际打印语句还是打印出来了。&lt;/p&gt;

&lt;p&gt;这一表现形式非常像闭包，因为参数明显在其生命周期外还存活。但是如果我们在 Lambda 表达式内试图修改参数 &lt;code&gt;s&lt;/code&gt; 的值后编译器会报 &lt;code&gt;s&lt;/code&gt; 必须为 &lt;code&gt;final&lt;/code&gt; ，这就是说该变量实际并不是自由变量，所以并不是真正的闭包。&lt;/p&gt;

&lt;p&gt;如果查看 Groovy 的闭包形式你可以发现 Groovy 实际也是通过实现继承自 &lt;code&gt;Closure&lt;/code&gt; 类的匿名内部类来实现闭包形式的，这一点与 Java 一致。所以理论上 Java 也能实现真正的闭包，至于 1.8 为什么没有这么做就不得而知了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - 16.方法 vs Lambda 表达式 vs 闭包 - 共通篇</title>
      <link>http://git.bookislife.com/post/2015/jgsk-16-method-lambda-closure-all/</link>
      <pubDate>Fri, 11 Dec 2015 12:12:21 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-16-method-lambda-closure-all/</guid>
      <description>

&lt;h2 id=&#34;共通篇:56c66497db86a5d0e04f79f652b89afb&#34;&gt;共通篇&lt;/h2&gt;

&lt;h3 id=&#34;方法-函数与过程:56c66497db86a5d0e04f79f652b89afb&#34;&gt;方法，函数与过程&lt;/h3&gt;

&lt;p&gt;这三种名词在编程中非常常见，其概念非常相近。一般来说函数 (Function) 是可重复调用带有有输出和输入的代码块。方法 (Method) 是定义在类中，作为类的成员的函数。过程(Subroutine)即没有返回值的函数。也就是说函数是基础，其它两种只是函数的特例。&lt;/p&gt;

&lt;p&gt;由于这些名词容易混淆，在 Java 中统一都使用方法这个名词。而在 Kotlin 中使用关键字 &lt;code&gt;fun&lt;/code&gt; 即表示 Kotlin 中使用的是函数这个名词。为了方便起见，本系列都使用方法这个名字进行描述，只有在牵涉到函数式编程时才使用函数这个名词。&lt;/p&gt;

&lt;h3 id=&#34;lambda-表达式:56c66497db86a5d0e04f79f652b89afb&#34;&gt;Lambda 表达式&lt;/h3&gt;

&lt;p&gt;所谓的 Lambda 表达式其实就是一个匿名函数。&lt;/p&gt;

&lt;h3 id=&#34;sam-类型:56c66497db86a5d0e04f79f652b89afb&#34;&gt;SAM 类型&lt;/h3&gt;

&lt;p&gt;SAM （Single Abstract Method）是有且仅有一个抽象方法的类型，该类型可以是抽象类也可以是接口。&lt;/p&gt;

&lt;h3 id=&#34;闭包:56c66497db86a5d0e04f79f652b89afb&#34;&gt;闭包&lt;/h3&gt;

&lt;p&gt;闭包是一种带有自由变量的代码块，其最显著的特性就是能够扩大局部变量的生命周期。&lt;/p&gt;

&lt;h4 id=&#34;闭包与-lambda-表达式:56c66497db86a5d0e04f79f652b89afb&#34;&gt;闭包与 Lambda 表达式&lt;/h4&gt;

&lt;p&gt;闭包与 Lambda 表达式的概念非常容易让人混淆，但两者确实是不同的东西。Lambda 表达式是匿名函数，而闭包则是实现函数是第一类对象的一种手段。两者的直接关系是 Lambda 表达式可以作为闭包的一种表现形式，但闭包除了 Lambda 表达式也可以表现为多种形式，这也就是在各种语言中闭包的写法会有很多差别的原因。&lt;/p&gt;

&lt;h4 id=&#34;闭包与方法:56c66497db86a5d0e04f79f652b89afb&#34;&gt;闭包与方法&lt;/h4&gt;

&lt;p&gt;闭包和方法的最大区别是方法执行完毕后其内部的变量便会被释放，而闭包不会。闭包可以进行嵌套，而方法不行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - Kotlin - 04.this</title>
      <link>http://git.bookislife.com/post/2015/jgsk-kotlin-04.this/</link>
      <pubDate>Thu, 10 Dec 2015 11:21:38 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-kotlin-04.this/</guid>
      <description>

&lt;h2 id=&#34;this:1e931cd5d904d224c2c174a487ecf297&#34;&gt;this&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在 Java 中 &lt;code&gt;this&lt;/code&gt; 通常用于指代当前对象，而在 Kotlin 中由于拥有闭包，扩展等特性，&lt;code&gt;this&lt;/code&gt; 的指代变得更加复杂。&lt;/li&gt;
&lt;li&gt;就像 Java 可以使用 &lt;code&gt;类名.this&lt;/code&gt; 类指代外部类的对象，Kotlin 中可以使用 `&lt;code&gt;this@类名&lt;/code&gt; 来达到同样效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，Kotlin 中的 &lt;code&gt;this&lt;/code&gt; 有以下原则&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类的成员中声明的 &lt;code&gt;this&lt;/code&gt; 指向当前类的对象&lt;/li&gt;
&lt;li&gt;扩展类的方法中的 &lt;code&gt;this&lt;/code&gt; 指向调用该方法的接收者&lt;/li&gt;
&lt;li&gt;没有任何限定的 &lt;code&gt;this&lt;/code&gt; 总是尽可能指向最小范围&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class A { // this 等于 this@A
    inner class B { // this 等于 this@B
        //  扩展方法隐式指向调用者
        fun Int.foo() {
            // this 等于 this@foo

            val funLit = { -&amp;gt;
                println(&amp;quot;this of funLit refers to $this&amp;quot;)   //  10
            }

            val funLit2 = { s: String -&amp;gt;
                println(&amp;quot;this of funLit2 refers to $this&amp;quot;)  //  10
            }

            println(&amp;quot;this refers to ${this}&amp;quot;)   //  10
            println(&amp;quot;this@foo refers to ${this@foo}&amp;quot;)   //  10

            println(&amp;quot;this@A refers to ${this@A}&amp;quot;)  //  A
            println(&amp;quot;this@B refers to ${this@B}&amp;quot;)  //  A$B

            funLit()
            funLit2(&amp;quot;foo&amp;quot;)
        }

        fun info() {
            // 类的成员方法指向当前对象即内部类 B
            println(&amp;quot;the member refers to $this&amp;quot;)    // A$B
            10.foo()
        }
    }
}

A().B().info()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结:1e931cd5d904d224c2c174a487ecf297&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以使用 &lt;code&gt;this@label&lt;/code&gt; 形式指向外部对象&lt;/li&gt;
&lt;li&gt;类的成员中声明的 &lt;code&gt;this&lt;/code&gt; 指向当前类的对象&lt;/li&gt;
&lt;li&gt;扩展类的方法中的 &lt;code&gt;this&lt;/code&gt; 指向调用该方法的接收者&lt;/li&gt;
&lt;li&gt;没有任何限定的 &lt;code&gt;this&lt;/code&gt; 总是尽可能指向最小范围&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;项目源码见 &lt;a href=&#34;https://github.com/SidneyXu/JGSK&#34;&gt;JGSK/k04_this&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - Kotlin - 03.委托</title>
      <link>http://git.bookislife.com/post/2015/jgsk-kotlin-03-delegation/</link>
      <pubDate>Thu, 10 Dec 2015 09:57:36 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-kotlin-03-delegation/</guid>
      <description>

&lt;h3 id=&#34;类的委托:1a8829e3bdb0b396a545ae85b9e002e3&#34;&gt;类的委托&lt;/h3&gt;

&lt;p&gt;类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。&lt;/p&gt;

&lt;p&gt;在 Java 中实现委托机制就像下面的例子一样，非常麻烦。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Base {
  public void echo(String message){
    System.out.println(message);
  }
}
//  委托类
class Delegation {
    private Base base;
    public Delegation(){
        this.base = new Base();
    }
    //  实际调用的是 Base 类的方法
    public void echo(String message){
        base.echo(message);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在 Kotlin 中只要被委托的类实现了接口，那么就可以很简单的建立一个拥有此接口所有公共实现方法的委托类。&lt;/p&gt;

&lt;p&gt;创建接口和实现此接口的被委托的类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface Base {
    fun echo(msg: String)
}

class BaseImpl(val prefix: String) : Base {
    override fun echo(msg: String) {
        println(&amp;quot;$prefix $msg&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立委托类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Derived(b: Base) : Base by b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上 &lt;code&gt;Derived&lt;/code&gt; 类继承了所有来自 &lt;code&gt;Base&lt;/code&gt; 的方法，并且委托一个传入的 &lt;code&gt;Base&lt;/code&gt; 类的对象来 执行这些方法。&lt;/p&gt;

&lt;p&gt;使用委托类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val b = BaseImpl(&amp;quot;Hello&amp;quot;)
b.echo(&amp;quot;World&amp;quot;) //  Hello World
val d = Derived(b)  //  Hello World
d.echo(&amp;quot;World&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;属性的委托:1a8829e3bdb0b396a545ae85b9e002e3&#34;&gt;属性的委托&lt;/h3&gt;

&lt;p&gt;属性的委托指的一个类的某个属性的值不是在类中直接进行定义，而是由某个类的方法来进行 setter 和 getter。默认属性委托都是线程安全的。属性委托适合那些属性的需要复杂的计算但是计算过程可以被重用的场合。&lt;/p&gt;

&lt;p&gt;定义一个被委托的类&lt;/p&gt;

&lt;p&gt;该类需要包含 &lt;code&gt;getValue()&lt;/code&gt; 方法和 &lt;code&gt;setValue()&lt;/code&gt; 方法，且参数 &lt;code&gt;thisRef&lt;/code&gt; 为进行委托的类的对象，&lt;code&gt;prop&lt;/code&gt; 为进行委托的属性的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Delegate {

    private var message = &amp;quot;Default Message&amp;quot;

    operator fun getValue(thisRef: Any?, prop: KProperty&amp;lt;*&amp;gt;): String {
        return &amp;quot;${prop.name} = $message from $thisRef&amp;quot;
    }

    operator fun setValue(thisRef: Any?, prop: KProperty&amp;lt;*&amp;gt;, value: String) {
        message = value
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义包含属性委托的类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Example {
    var msg: String by Delegate()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问该属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val e = Example()
println(e.msg)  //  msg = Default Message

e.msg = &amp;quot;New Message&amp;quot;
println(e.msg)  //  msg = New Message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用属性委托时，被委托的类的方法（即接收者）的返回值必须与委托的属性相同或者其父类。&lt;/p&gt;

&lt;h3 id=&#34;标准委托:1a8829e3bdb0b396a545ae85b9e002e3&#34;&gt;标准委托&lt;/h3&gt;

&lt;p&gt;Kotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。&lt;/p&gt;

&lt;h4 id=&#34;lazy:1a8829e3bdb0b396a545ae85b9e002e3&#34;&gt;Lazy&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;lazy&lt;/code&gt; 用于进行惰性加载，在 &lt;code&gt;JGSK - 34.Lazy&lt;/code&gt; 章节中已经介绍过了。&lt;/p&gt;

&lt;h4 id=&#34;observable:1a8829e3bdb0b396a545ae85b9e002e3&#34;&gt;Observable&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;observable&lt;/code&gt; 可以用于实现观察者模式。&lt;/p&gt;

&lt;p&gt;定义包含被委托的属性的类&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Delegates.observable&lt;/code&gt; 接收三个参数：包含委托的属性的元数据的 &lt;code&gt;KProperty&lt;/code&gt; 对象，旧值，新值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class User {
    var name: String by Delegates.observable(&amp;quot;&amp;lt;init value&amp;gt;&amp;quot;) {
        prop, old, new -&amp;gt;
        if (old != new) {
            println(&amp;quot;$old -&amp;gt; $new&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问该属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val user = User()
user.name = &amp;quot;first&amp;quot; //  &amp;lt;init value&amp;gt; -&amp;gt; first
user.name = &amp;quot;first&amp;quot;
user.name = &amp;quot;second&amp;quot;    //  first -&amp;gt; second
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用 &lt;code&gt;vetoable&lt;/code&gt; 代替 &lt;code&gt;observable&lt;/code&gt;，该方法拥有布尔类型的返回值，返回 &lt;code&gt;false&lt;/code&gt; 的话可以取消对该属性的修改。&lt;/p&gt;

&lt;p&gt;在以上 &lt;code&gt;User&lt;/code&gt; 中定义一个新属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;var age: Int by Delegates.vetoable(0) {
    prop, old, new -&amp;gt;
    println(&amp;quot;$old -&amp;gt; $new&amp;quot;)
    if (new &amp;lt; 20) true else false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问该属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;user.age = 10   //  0 -&amp;gt; 10
println(user.age)   //  10
user.age = 20   //  10 -&amp;gt; 20
println(user.age)   //  20
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;not-null:1a8829e3bdb0b396a545ae85b9e002e3&#34;&gt;Not Null&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;notNull&lt;/code&gt; 适用于那些无法在初始化阶段就确定属性值的场合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Foo {
    var notNullBar: String by Delegates.notNull&amp;lt;String&amp;gt;()
}

foo.notNullBar = &amp;quot;bar&amp;quot;
println(foo.notNullBar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意，如果属性在赋值前就被访问的话则会抛出异常。&lt;/p&gt;

&lt;h4 id=&#34;以-map-形式保存属性的值:1a8829e3bdb0b396a545ae85b9e002e3&#34;&gt;以 Map 形式保存属性的值&lt;/h4&gt;

&lt;p&gt;Kotlin 中有一种特别的委托，可以以 Map 作为一个类的构造方法的参数，访问该类的属性就是访问该 Map 的键值对。这种做法非常类似 Groovy 中的带名构造方法。&lt;/p&gt;

&lt;p&gt;要实现这一功能需要得意于 Kotlin 内置的属性的扩展方法 &lt;code&gt;kotlin.properties.getValue&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;import kotlin.properties.getValue

class Person(val map: Map&amp;lt;String, Any?&amp;gt;) {
    val name: String by map
    val age: Int by map
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以像普通类一样访问其各个属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val person = Person(mapOf(
        &amp;quot;name&amp;quot; to &amp;quot;John&amp;quot;,
        &amp;quot;age&amp;quot; to 25
))
println(person.name)
println(person.age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于可变值，可以使用 &lt;code&gt;MutableMap&lt;/code&gt; 代替，并导入扩展方法 &lt;code&gt;kotlin.properties.setValue&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;import kotlin.properties.setValue

class MutablePerson(val map: MutableMap&amp;lt;String, Any?&amp;gt;) {
    var name: String by map
    var age: Int     by map
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结:1a8829e3bdb0b396a545ae85b9e002e3&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Kotlin 支持类的委托和属性的委托。&lt;/li&gt;
&lt;li&gt;标准库中内置 &lt;code&gt;lazy&lt;/code&gt;,&lt;code&gt;observable&lt;/code&gt;,&lt;code&gt;vetoable&lt;/code&gt; 等实现委托的工厂方法。&lt;/li&gt;
&lt;li&gt;可以使用 map 委托来实现类似 Groovy 的默认构造方法&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;项目源码见 &lt;a href=&#34;https://github.com/SidneyXu/JGSK&#34;&gt;JGSK/k03_delegate&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - Kotlin - 02.Extension</title>
      <link>http://git.bookislife.com/post/2015/jgsk-kotlin-02-extension/</link>
      <pubDate>Wed, 09 Dec 2015 09:59:58 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-kotlin-02-extension/</guid>
      <description>

&lt;h2 id=&#34;extension:3038309976c87702036960b7bb454271&#34;&gt;Extension&lt;/h2&gt;

&lt;p&gt;Extension 是 Kotlin 中一个非常强大的功能，主要用于对已经定义好的类的行为或者属性进行扩展，这一特性非常类似 Javascript 中的 Prototype。&lt;/p&gt;

&lt;h3 id=&#34;扩展类的行为:3038309976c87702036960b7bb454271&#34;&gt;扩展类的行为&lt;/h3&gt;

&lt;p&gt;先定义一个需要被扩展的类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Num(var x: Int) {
    fun add(y: Int) {
        x += y
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上定义一个 &lt;code&gt;Num&lt;/code&gt;，该类包含一个方法 &lt;code&gt;add()&lt;/code&gt;，用于将内置的变量与一个参数进行相加。&lt;/p&gt;

&lt;p&gt;接下来扩展该类，为其添加一个将内置变量与两个参数进行相加的方法，语法为 &lt;code&gt;类.方法(){}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun Num.add(a: Int, b: Int) {
    this.x += a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着就可以正常进行调用了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;var n: Num = Num(10)
n.add(4)
n.add(1, 3)
println(n.x)    //  18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;扩展功能不仅可以用于自定义的类，也可以用于内置的类。但是需要注意如果添加的扩展的方法与类中已存在的方法同名时，则该类的实例调用的始终是类中已定义的方法，而不会调用扩展的方法。&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Num(var x: Int) {
    fun foo() {
        println(&amp;quot;foo in Num&amp;quot;)
    }
}
fun Num.foo() {
    println(&amp;quot;foo in extension&amp;quot;)
}
n.foo()         //  foo in Num
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;扩展类的属性:3038309976c87702036960b7bb454271&#34;&gt;扩展类的属性&lt;/h3&gt;

&lt;p&gt;扩展类的属性用法基本同扩展类的行为。以下展示为内置类 List 添加一个能够直接访问其第二个元素的新的属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt;.second: T
    get() = get(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用该属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val l: List&amp;lt;Int&amp;gt; = listOf(1, 2, 3)
println(l.second)  //  2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;扩展伴生对象:3038309976c87702036960b7bb454271&#34;&gt;扩展伴生对象&lt;/h3&gt;

&lt;p&gt;扩展伴生对象时使用方式略微不同，需要添加中间类 &lt;code&gt;Companion&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;定义一个包含伴生对象的类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MyClass {
    companion object {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;扩展其伴生对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun MyClass.Companion.foo() {
    println(&amp;quot;foo in companion object&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用扩展的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;MyClass.foo()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结:3038309976c87702036960b7bb454271&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Kotlin 中可以扩展已经定义的类的行为和属性。&lt;/li&gt;
&lt;li&gt;扩展的行为或属性如果与类中已定义的成员同名则会被忽略。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;项目源码见 &lt;a href=&#34;https://github.com/SidneyXu/JGSK&#34;&gt;JGSK/k02_extension&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - Kotlin - 01.多重声明</title>
      <link>http://git.bookislife.com/post/2015/jgsk-kotlin-01-mulitdecl/</link>
      <pubDate>Tue, 08 Dec 2015 15:19:51 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-kotlin-01-mulitdecl/</guid>
      <description>

&lt;h2 id=&#34;多重声明:690ae328721fdb3986fff2969fc6d1a0&#34;&gt;多重声明&lt;/h2&gt;

&lt;p&gt;多重声明类似 Scala 中的 &lt;code&gt;unapply&lt;/code&gt;，主要用于对对象进行拆箱。&lt;/p&gt;

&lt;p&gt;实现多重声明只要在任意类内部定义了 &lt;code&gt;componentN()&lt;/code&gt; 方法（N 为任意自然数）即可并加上 &lt;code&gt;operator&lt;/code&gt; 关键字即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Person(val name: String, val age: Int) {
    operator fun component1(): String {
        return name
    }

    operator fun component2(): Int {
        return age
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上类 &lt;code&gt;Person&lt;/code&gt; 定义了两个 &lt;code&gt;componentN()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;如果需要进行拆箱的话则需要定义变量时将变量放在括号中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val person = Person(&amp;quot;Jane&amp;quot;, 20)
val  (name, age) = person
println(name)   //  Jane
println(age)    //  20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上便进行了完整的拆箱操作，但是拆箱用的变量数量也可以小于声明的 component 数量，即以下例子也是可以的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val (n) = person
println(n)  //  Jane
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是以上括号不能省略，否则等于将 person 赋给变量 n。&lt;/p&gt;

&lt;h2 id=&#34;总结:690ae328721fdb3986fff2969fc6d1a0&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;多重声明用于对对象进行拆箱操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;项目源码见 &lt;a href=&#34;https://github.com/SidneyXu/JGSK&#34;&gt;JGSK/k01_mulitdeclartion&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JGSK - 34.Lazy</title>
      <link>http://git.bookislife.com/post/2015/jgsk-34-lazy/</link>
      <pubDate>Tue, 08 Dec 2015 10:44:06 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/jgsk-34-lazy/</guid>
      <description>

&lt;h2 id=&#34;共通篇:b05145dc63db7fff7c79ee99b4aad208&#34;&gt;共通篇&lt;/h2&gt;

&lt;p&gt;Lazy变量也就是常说的惰性加载，即变量在初始化时没有进行计算操作，而是延迟到了该变量第一次被使用的时候。在函数式编程中，惰性加载被广泛使用，尤其是对于一些长度未知的列表，如果使用普通方式，恐怕加载时系统就会被拖慢速度甚至于内存溢出。&lt;/p&gt;

&lt;h2 id=&#34;java:b05145dc63db7fff7c79ee99b4aad208&#34;&gt;Java&lt;/h2&gt;

&lt;p&gt;Java 并不支持惰性加载，所以以往一般都是通过代理对象的形式来模拟实习。不过从 Java 1.8 开始可以使用更简单的 Lambda 表达式来实现此功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class A {
    private Supplier&amp;lt;Long&amp;gt; fooField = () -&amp;gt; {
        Long val = expensiveInit();
        fooField = () -&amp;gt; val;
        return val;
    };

    protected Long expensiveInit() {
        System.out.println(&amp;quot;Compute...&amp;quot;);
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return System.currentTimeMillis();
    }

    public Long getFoo() {
        return fooField.get();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用以下代码观察控制台输出就可以看出区别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(&amp;quot;Before is &amp;quot; + System.currentTimeMillis());
A a = new A();
System.out.println(&amp;quot;After is &amp;quot; + System.currentTimeMillis());
System.out.println(&amp;quot;Hello 1, &amp;quot; + a.getFoo());
System.out.println(&amp;quot;Hello 2, &amp;quot; + a.getFoo());
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;groovy:b05145dc63db7fff7c79ee99b4aad208&#34;&gt;Groovy&lt;/h2&gt;

&lt;p&gt;Groovy 中可以通过 &lt;code&gt;@Lazy&lt;/code&gt;  注解和自释放的闭包来实现惰性加载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;class A {
    def fooField = {
        println(&amp;quot;Compute...&amp;quot;)
        Thread.sleep(3000)
        System.currentTimeMillis()
    }()

    @Lazy
    def lazyField = {
        println(&amp;quot;Compute...&amp;quot;)
        Thread.sleep(3000)
        System.currentTimeMillis()
    }()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用以下代码观察控制台输出就可以看出区别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;println(&amp;quot;Before is ${System.currentTimeMillis()}&amp;quot;)
def a = new A()
println(&amp;quot;After is ${System.currentTimeMillis()}&amp;quot;)
println(&amp;quot;Hello 1, ${a.fooField}&amp;quot;)
println(&amp;quot;Hello 2, ${a.fooField}&amp;quot;)

println(&amp;quot;Hello 1, ${a.lazyField}&amp;quot;)
println(&amp;quot;Hello 2, ${a.lazyField}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scala:b05145dc63db7fff7c79ee99b4aad208&#34;&gt;Scala&lt;/h2&gt;

&lt;h3 id=&#34;lazy:b05145dc63db7fff7c79ee99b4aad208&#34;&gt;lazy&lt;/h3&gt;

&lt;p&gt;Scala 中通过 &lt;code&gt;lazy&lt;/code&gt; 关键字来实现惰性加载的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class A {
  val fooField = {
    println(&amp;quot;Compute...&amp;quot;)
    Thread.sleep(3000)
    System.currentTimeMillis()
  }

  lazy val lazyField = {
    println(&amp;quot;Compute...&amp;quot;)
    Thread.sleep(3000)
    System.currentTimeMillis()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用以下代码观察控制台输出就可以看出区别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;println(s&amp;quot;Before is ${System.currentTimeMillis()}&amp;quot;)
val a = new A()
println(s&amp;quot;After is ${System.currentTimeMillis()}&amp;quot;)
println(s&amp;quot;Hello 1, ${a.fooField}&amp;quot;)
println(s&amp;quot;Hello 2, ${a.fooField}&amp;quot;)

println(s&amp;quot;Hello 1, ${a.lazyField}&amp;quot;)
println(s&amp;quot;Hello 2, ${a.lazyField}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;var-val-lazy-val-def-的区别:b05145dc63db7fff7c79ee99b4aad208&#34;&gt;var, val, lazy val, def 的区别&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;var&lt;/code&gt;, &lt;code&gt;val&lt;/code&gt;, &lt;code&gt;lazy val&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt; 这四个在有些时候用法看起来有些相似，很容易让人搞混。接下来通过一个例子来进行区分：&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class A {
  var max = 100
  def init(m: Int) = max = m
  val valValue = Random.nextInt(max)
  var varValue = Random.nextInt(max)
  lazy val lazyValValue = Random.nextInt(max)
  def defValue = Random.nextInt(max)
}

val a = new A()
a.init(1000000)
println(s&amp;quot;val=${a.valValue}&amp;quot;) //  96
println(s&amp;quot;var=${a.varValue}&amp;quot;) //  9
println(s&amp;quot;lazy val=${a.lazyValValue}&amp;quot;) //  117261
println(s&amp;quot;def=${a.defValue}&amp;quot;) //  798062

println(s&amp;quot;val=${a.valValue}&amp;quot;) //  96
println(s&amp;quot;var=${a.varValue}&amp;quot;) //  9
println(s&amp;quot;lazy val=${a.lazyValValue}&amp;quot;) //  117261
println(s&amp;quot;def=${a.defValue}&amp;quot;) //  937263
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从以上的例子中可以知道这四个有以下的区别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var&lt;/code&gt; 定义变量，在类初始化时的同时被初始化，除非被手动赋值，再次访问时会直接使用之前的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;val&lt;/code&gt; 定义值（常量），在类初始化时的同时被初始化，无法被修改，再次访问时会直接使用之前的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lazy val&lt;/code&gt; 定义惰性加载值，在第一次使用被初始化，无法被修改，再次访问时会直接使用之前的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;def&lt;/code&gt; 定义函数，单行时看起来很像定义变量，但是访问时实际是调用函数，所以多次调用时值会重新计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;kotlin:b05145dc63db7fff7c79ee99b4aad208&#34;&gt;Kotlin&lt;/h2&gt;

&lt;p&gt;Kotlin 中通过 &lt;code&gt;lazy()&lt;/code&gt; 函数来实现惰性加载功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class A {
    val fooField: Long by lazy {
        println(&amp;quot;Compute...&amp;quot;)
        Thread.sleep(3000)
        System.currentTimeMillis()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用以下代码观察控制台输出就可以看出区别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;println(&amp;quot;Before is ${System.currentTimeMillis()}&amp;quot;)
val a = A()
println(&amp;quot;After is ${System.currentTimeMillis()}&amp;quot;)
println(&amp;quot;Hello 1, ${a.fooField}&amp;quot;)
println(&amp;quot;Hello 2, ${a.fooField}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kotlin 中使用惰性加载时还能指定线程安全的模式，默认惰性加载是同步的（LazyThreadSafetyMode.SYNCHRONIZED，只能有一个线程进行修改，结果对所有线程可见），但是也可以指定为公开的(PUBLICATION，所有线程可以同时进行计算，但是只有第一个完成计算的线程会被作为结果) ， 或者不加任何限制(NONE，没有任何线程安全的措施，效率最高，适合本来就是单线程执行计算的程序)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val fooField2: Long by lazy(LazyThreadSafetyMode.PUBLICATION) {
    println(&amp;quot;Compute...&amp;quot;)
    Thread.sleep(3000)
    System.currentTimeMillis()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结:b05145dc63db7fff7c79ee99b4aad208&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;除了 Java 之外，其它三种语言都默认支持惰性加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;项目源码见 &lt;a href=&#34;https://github.com/SidneyXu/JGSK&#34;&gt;JGSK/_34_lazy&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>