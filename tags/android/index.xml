<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Pixel Space</title>
    <link>http://git.bookislife.com/tags/android/</link>
    <description>Recent content in Android on Pixel Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright (c) 2015, Sidney Xu; all rights reserved.</copyright>
    <lastBuildDate>Sat, 19 Mar 2016 13:22:59 +0800</lastBuildDate>
    <atom:link href="http://git.bookislife.com/tags/android/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>常用 adb 命令</title>
      <link>http://git.bookislife.com/post/2016/adb-command/</link>
      <pubDate>Sat, 19 Mar 2016 13:22:59 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2016/adb-command/</guid>
      <description>

&lt;p&gt;ADB 命令很多，本文只介绍实际常用的那些命令&lt;/p&gt;

&lt;h2 id=&#34;常用-adb-命令:274207f69d1414b83d961bffbbaaab6f&#34;&gt;常用 adb 命令&lt;/h2&gt;

&lt;h3 id=&#34;基本操作:274207f69d1414b83d961bffbbaaab6f&#34;&gt;基本操作&lt;/h3&gt;

&lt;p&gt;列出当前所有设备名，包含真机和模拟器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb devices
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启 adb 调试桥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;start-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭 adb 调试桥，当 Logcat 显示设备 offline 时可用通过重启调试桥恢复功能&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kill-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示手机硬件信息，包括 device model 等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb shell cat system/build.prop
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;应用相关:274207f69d1414b83d961bffbbaaab6f&#34;&gt;应用相关&lt;/h3&gt;

&lt;p&gt;安装应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb install &amp;lt;apk&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;卸载应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;uninstall &amp;lt;packageName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示所有安装的应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb shell pm list packages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开 Schema&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb shell am start -W -a android.intent.action.VIEW -d &amp;lt;schema&amp;gt; &amp;lt;packageName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt; 指定 action&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 指定 data uri&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;打开 Activity&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb shell am start -n &amp;lt;packageName&amp;gt;/&amp;lt;targetActivity&amp;gt; [-e somekey somevalue]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; 相当于向 intent 放入 String 类型的 extra 参数，&lt;code&gt;-ei&lt;/code&gt; 则为 int 类型 value，&lt;code&gt;-el&lt;/code&gt; 为 long 类型 value，其它类推&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：如果该 Activity 不是 Main Activity 的话，则必须设置 &lt;code&gt;android:export=“true”&lt;/code&gt; ，否则会报没有权限&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;文件操作:274207f69d1414b83d961bffbbaaab6f&#34;&gt;文件操作&lt;/h3&gt;

&lt;p&gt;拷贝文件到手机&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb push &amp;lt;local_path&amp;gt; &amp;lt;remote_path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从手机拷贝文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb pull &amp;lt;remote_path&amp;gt; &amp;lt;local_path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;截图:274207f69d1414b83d961bffbbaaab6f&#34;&gt;截图&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb shell screencap -p &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt; 表示保存为 png 格式，不指定的话 filename 必须指定后缀名。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;wakelock:274207f69d1414b83d961bffbbaaab6f&#34;&gt;wakelock&lt;/h3&gt;

&lt;p&gt;显示所有 wakelock 情况&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb shell cat /sys/kernel/debug/wakeup_sources
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示电源状况&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb shell dumpsys power
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找一个应用是否错误地占用了 wakelock&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;按下电源键关闭屏幕&lt;/li&gt;
&lt;li&gt;等待 20s&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;adb shell dumpsys power | grep PARTIAL&lt;/code&gt;，查看输出结果是否有这样的形式 &lt;code&gt;PARTIAL_WAKE_LOCK ‘AudioOut_2’ activated(minState=0, uid=1013, pid=157)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重复 2-4 多次，如果还是一直能获得该锁则证明其存在 Bug，没有正常释放锁&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>使用 Scala 开发 Android 应用</title>
      <link>http://git.bookislife.com/post/2016/dev-android-using-scala/</link>
      <pubDate>Sun, 10 Jan 2016 20:01:39 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2016/dev-android-using-scala/</guid>
      <description>

&lt;h1 id=&#34;scala-android:7bfeba4c498bcdcfccf91ff07c06adf4&#34;&gt;Scala Android&lt;/h1&gt;

&lt;h2 id=&#34;场景:7bfeba4c498bcdcfccf91ff07c06adf4&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;之前介绍了使用 Groovy 和 Kotlin 开发 Android 程序，本节主要介绍如何使用 Scala 开发 Android 程序。&lt;/p&gt;

&lt;h2 id=&#34;环境配置:7bfeba4c498bcdcfccf91ff07c06adf4&#34;&gt;环境配置&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在 IDEA 或 Android Studio 中安装 &lt;code&gt;Scala&lt;/code&gt; 插件。步骤：打开 &lt;code&gt;Settings&lt;/code&gt; 或 &lt;code&gt;Preferences&lt;/code&gt; 选择 &lt;code&gt;Plugins&lt;/code&gt;，点击 &lt;code&gt;Browser repositories&lt;/code&gt; 输入 &lt;code&gt;Scala&lt;/code&gt; 进行安装，安装完后重启 IDE。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建立一个空的 Android 项目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改 &lt;code&gt;build.gradle&lt;/code&gt; 文件&lt;/p&gt;

&lt;p&gt;添加 &lt;code&gt;gradle-android-scala-plugin&lt;/code&gt; 插件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:1.2.3&#39;
        classpath &amp;quot;jp.leafytree.gradle:gradle-android-scala-plugin:1.4&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 plugin&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply plugin: &amp;quot;jp.leafytree.android-scala&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 runtime&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    compile &amp;quot;org.scala-lang:scala-library:2.11.7&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 sourceSets&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;android {
    sourceSets {
       main.scala.srcDirs += &#39;src/main/scala&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 &lt;code&gt;scaloid&lt;/code&gt; 作为 Android 的 Scala 扩展&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    compile &amp;quot;org.scaloid:scaloid_2.11:4.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为 Scala 环境过大会导致 65535 的错误，所以需要开启混淆。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;添加混淆&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-dontoptimize
-dontobfuscate
-dontpreverify
-dontwarn scala.**
-ignorewarnings
# temporary workaround; see Scala issue SI-5397
-keep class scala.collection.SeqLike {
    public protected *;
}

# this can be omitted if current Android Build target is android-16
-dontwarn org.scaloid.**
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启混淆&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildTypes {
    debug {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
    }
    release {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整的 &lt;code&gt;build.gradle&lt;/code&gt; 文件可以见 &lt;a href=&#34;https://github.com/SidneyXu/templates/blob/master/ScalaAndroid/app/build.gradle&#34;&gt;示例&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;编写代码:7bfeba4c498bcdcfccf91ff07c06adf4&#34;&gt;编写代码&lt;/h2&gt;

&lt;h3 id=&#34;使用-scala-的语法:7bfeba4c498bcdcfccf91ff07c06adf4&#34;&gt;使用 Scala 的语法&lt;/h3&gt;

&lt;p&gt;使用 Scala 后可以省略分号，也可以使用更优雅的类型转换方式。&lt;/p&gt;

&lt;p&gt;Java 的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
View getView(final int position, final View convertView, final ViewGroup parent) {
    View view = super.getView(position, convertView, parent);
    TextView title = view.findViewById(android.R.id.text1);
    title.setText(getItem(position));
    return view;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scala 的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Scala&#34;&gt;override def getView(position: Int, convertView: View, parent: ViewGroup): View = {
    val view: View = super.getView(position, convertView, parent)
    val title = view.findViewById(android.R.id.text1).asInstanceOf[TextView]
    title.setText(getItem(position))
    view
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-scaloid:7bfeba4c498bcdcfccf91ff07c06adf4&#34;&gt;使用 scaloid&lt;/h3&gt;

&lt;p&gt;scaloid 中使用了大量的隐式参数和 DSL 语句，使 Android 程序的开发方便不少。&lt;/p&gt;

&lt;p&gt;最简单的使用 scaloid 的方法就是继承 &lt;code&gt;SActivity&lt;/code&gt; 类。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import org.scaloid.common._

class MainActivity extends SActivity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以使用 scaloid 提供的方法来简化代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;find[Button](android.R.id.button1).text = &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而不使用此功能的话则需要使用以下代码，麻烦了很多&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;((TextView)findViewById(R.id.button1)).setText(&amp;quot;hello world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用闭包替代匿名类:7bfeba4c498bcdcfccf91ff07c06adf4&#34;&gt;使用闭包替代匿名类&lt;/h3&gt;

&lt;p&gt;匿名类的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;findViewById(android.R.id.button1).setOnClickListener(new View.OnClickListener() {
    @Override
    void onClick(final View v) {
        startActivity(new Intent(MainActivity.this, CountryListActivity.class))
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;闭包的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;find[Button](android.R.id.button1).onClick((v: View) =&amp;gt;
    startActivity[CountryListActivity]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用闭包替代回调:7bfeba4c498bcdcfccf91ff07c06adf4&#34;&gt;使用闭包替代回调&lt;/h3&gt;

&lt;p&gt;同 Groovy 一样，使用闭包替代回调也是一种通常的做法。&lt;/p&gt;

&lt;p&gt;Java 的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//  定义回调接口
public interface FindCallback {
    void onFinish(List&amp;lt;String&amp;gt; results, Exception e);
}
//  定义耗时任务
void findCountries(FindCallback doneCallback) {
    try {
        //  耗时任务
        doneCallback.onFinish(results, null);
    } catch (Exception e) {
        doneCallback.onFinish(null, e);
    }
}
//  调用该方法
findCountries(new FindCallback(){
    void onFinish(List&amp;lt;String&amp;gt; results, Exception e){
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scala 的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//  定义耗时任务
def findCountries(doneCallback: (ArrayBuffer[String], Exception) =&amp;gt; Unit):Unit = {
    try {
        //  耗时任务
        doneCallback(results, null)
    } catch {
        case e: Exception =&amp;gt; callback(null, e)
    }
}
//  调用该方法
findCountries((names: ArrayBuffer[String], e: Exception) =&amp;gt;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到使用闭包后无需预先定义回调接口，方便很多。&lt;/p&gt;

&lt;p&gt;完整的 Android 示例见 &lt;a href=&#34;https://github.com/SidneyXu/templates/tree/master/ScalaAndroid&#34;&gt;ScalaAndroid&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;参考资料:7bfeba4c498bcdcfccf91ff07c06adf4&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/saturday06/gradle-android-scala-plugin&#34;&gt;Github gradle-android-scala-plugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pocorall/scaloid&#34;&gt;Github scaloid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Android应用的重新打包与反编译</title>
      <link>http://git.bookislife.com/post/2016/android-repack-and-decompiler/</link>
      <pubDate>Mon, 04 Jan 2016 17:31:18 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2016/android-repack-and-decompiler/</guid>
      <description>

&lt;h2 id=&#34;android应用的重新打包与反编译:ea1950e20e16c27fed887e28a6d47b1f&#34;&gt;Android应用的重新打包与反编译&lt;/h2&gt;

&lt;h3 id=&#34;应用的重新打包:ea1950e20e16c27fed887e28a6d47b1f&#34;&gt;应用的重新打包&lt;/h3&gt;

&lt;p&gt;Android 开发中流传着所谓的“打包党”，即将其他开发者开发的畅销应用解开后修改部分内容（比如广告 Id 等）然后重新进行打包上传到商店以谋求暴利。以下就介绍以下如何对一个应用进行重新打包：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先任意准备一个应用用于进行测试，这里随意写了一个应用 &lt;code&gt;testapp.apk&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://ibotpeaches.github.io/Apktool/install/&#34;&gt;下载 Apktool&lt;/a&gt;，按照说明进行安装&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解开 &lt;code&gt;testapp.apk&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./apktool d testapp.apk -o testapp
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看解开的目录下的 &lt;code&gt;META-INF/CERT.RSA&lt;/code&gt;，该文件存储有原应用的签名&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;keytool -printcert -file testapp/original/META-INF/CERT.RSA
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;模仿“打包党”，尝试修改 &lt;code&gt;AndroidManifest.xml&lt;/code&gt; 中的包名和应用名。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重新打包应用为 &lt;code&gt;new_testapp.apk&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./apktool b testapp -o new_testapp.apk
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成一个新的 keystore&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;keytool -genkey -v -keystore androidse.keystore -alias androidsekey -keyalg RSA -keysize 2048 -validity 365
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用刚刚生成的 keystore 对重新打包生成的 &lt;code&gt;new_testapp.apk&lt;/code&gt; 进行重新签名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;jarsigner -verbose -sigalg MD5withRSA -digestalg SHA1 -keystore androidse.keystore new_testapp.apk androidsekey
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;验证签名是否正确打到应用上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;jarsigner -verify -verbose -certs new_testapp.apk
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对齐 apk，应用要想上 Google Play 必须进行对齐操作，对齐后生成新的应用 &lt;code&gt;new_testapp_align.apk&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ANDROID_HOME/build-tools/23.0.2/zipalign -v 4 new_testapp.apk new_testapp_align.apk
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上就完成了最简单的重新打包操作。&lt;/p&gt;

&lt;h3 id=&#34;反编译应用:ea1950e20e16c27fed887e28a6d47b1f&#34;&gt;反编译应用&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载必要软件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pxb1988/dex2jar&#34;&gt;下载 dex2Jar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jd.benow.ca/&#34;&gt;下载 j2-gui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改权限&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chmod +x jd-gui-1.4.0.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解压需要反编译的 apk 获得其中的 &lt;code&gt;classes.dex&lt;/code&gt; 文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;反编译 dex 文件为 class 文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dex2jar-2.0/d2j-dex2jar.sh testapp/build/apk/classes.dex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完毕后会在当前文件夹下会生成 &lt;code&gt;classes-dex2jar.jar&lt;/code&gt; 文件，该文件包含所有该应用相关的 class 文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开 jd-gui，选择刚才生成的 jar 文件就可以看到反编译后获得的内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar jd-gui-1.4.0.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>使用 Kotlin 开发 Android 应用</title>
      <link>http://git.bookislife.com/post/2015/dev-android-using-kotlin/</link>
      <pubDate>Mon, 30 Nov 2015 17:46:07 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/dev-android-using-kotlin/</guid>
      <description>

&lt;h1 id=&#34;kotlin-android:9d05dee5736f4f1c0148629e5dc91f56&#34;&gt;Kotlin Android&lt;/h1&gt;

&lt;h2 id=&#34;场景:9d05dee5736f4f1c0148629e5dc91f56&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;之前介绍了使用 Groovy 开发 Android 程序，本节主要介绍如何使用 Kotlin 开发 Android 程序。&lt;/p&gt;

&lt;h2 id=&#34;环境配置:9d05dee5736f4f1c0148629e5dc91f56&#34;&gt;环境配置&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在 IDEA 或 Android Studio 中安装 &lt;code&gt;Kotlin&lt;/code&gt; 插件。步骤：打开 &lt;code&gt;Settings&lt;/code&gt; 或 &lt;code&gt;Preferences&lt;/code&gt; 选择 &lt;code&gt;Plugins&lt;/code&gt;，点击 &lt;code&gt;Browser repositories&lt;/code&gt; 输入 &lt;code&gt;Kotlin&lt;/code&gt; 进行安装，安装完后再安装 &lt;code&gt;Kotlin Extensions For Android&lt;/code&gt;，安装完后重启 IDE。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建立一个空的 Android 项目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改 &lt;code&gt;build.gradle&lt;/code&gt; 文件&lt;/p&gt;

&lt;p&gt;添加 &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; 插件和用于扩展 Android 功能的 &lt;code&gt;kotlin-android-extensions&lt;/code&gt; 插件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildscript {
    ext.kotlin_version = &#39;1.0.0&#39;
    repositories {
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:1.2.3&#39;
        classpath &amp;quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&amp;quot;
        classpath &amp;quot;org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 plugin&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply plugin: &#39;kotlin-android&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 maven 仓库，Kotlin 相关依赖都保存在 maven 中央仓库中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;repositories {
    jcenter()
    mavenCentral()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 runtime&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    compile &amp;quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 sourceSets&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;android {
    sourceSets {
       main.java.srcDirs += &#39;src/main/kotlin&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完整的 &lt;code&gt;build.gradle&lt;/code&gt; 文件可以见 &lt;a href=&#34;https://github.com/SidneyXu/templates/blob/master/KotlinAndroid/app/build.gradle&#34;&gt;示例&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;编写代码:9d05dee5736f4f1c0148629e5dc91f56&#34;&gt;编写代码&lt;/h2&gt;

&lt;h3 id=&#34;使用-kotlin-的语法:9d05dee5736f4f1c0148629e5dc91f56&#34;&gt;使用 Kotlin 的语法&lt;/h3&gt;

&lt;p&gt;使用 Kotlin 后可以省略分号，也可以使用更优雅的类型转换方式。&lt;/p&gt;

&lt;p&gt;Java 的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
View getView(final int position, final View convertView, final ViewGroup parent) {
    View view = super.getView(position, convertView, parent);
    TextView title = view.findViewById(android.R.id.text1);
    title.setText(getItem(position));
    return view;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kotlin 的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View? {
    val view = super.getView(position, convertView, parent)
    val title = view.findViewById(android.R.id.text1) as TextView
    title.text = getItem(position)
    return view
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-kotlin-extension:9d05dee5736f4f1c0148629e5dc91f56&#34;&gt;使用 Kotlin Extension&lt;/h3&gt;

&lt;p&gt;Kotlin Extension 类似 Android 新加入的 DataBinding，可以直接对控件进行引用，但是使用起来更加方便。&lt;/p&gt;

&lt;p&gt;比如说在 &lt;code&gt;activity_main.xml&lt;/code&gt; 中定义了一个按钮，Kotlin Extension 会生成包含整个 Layout 内容的类 &lt;code&gt;kotlinx.android.synthetic.activity_main&lt;/code&gt;，为了方便起见，在文件头可以全部引入其内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;import kotlinx.android.synthetic.activity_main.*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后就可以直接对其进行引用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;button1.text = &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而不使用此功能的话则需要使用以下代码，麻烦了很多&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;((Button)findViewById(R.id.button1)).setText(&amp;quot;hello world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用闭包替代匿名类:9d05dee5736f4f1c0148629e5dc91f56&#34;&gt;使用闭包替代匿名类&lt;/h3&gt;

&lt;p&gt;匿名类的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;findViewById(android.R.id.button1).setOnClickListener(new View.OnClickListener() {
    @Override
    void onClick(final View v) {
        startActivity(new Intent(MainActivity.this, CountryListActivity.class))
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;闭包的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;button1.setOnClickListener {
    startActivity(new Intent(this, CountryListActivity.class))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用闭包替代回调:9d05dee5736f4f1c0148629e5dc91f56&#34;&gt;使用闭包替代回调&lt;/h3&gt;

&lt;p&gt;同 Groovy 一样，使用闭包替代回调也是一种通常的做法。&lt;/p&gt;

&lt;p&gt;Java 的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//  定义回调接口
public interface FindCallback {
    void onFinish(List&amp;lt;String&amp;gt; results, Exception e);
}
//  定义耗时任务
void findCountries(FindCallback doneCallback) {
    try {
        //  耗时任务
        doneCallback.onFinish(results, null);
    } catch (Exception e) {
        doneCallback.onFinish(null, e);
    }
}
//  调用该方法
findCountries(new FindCallback(){
    void onFinish(List&amp;lt;String&amp;gt; results, Exception e){
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kotlin 的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;//  定义耗时任务
fun findCountries(doneCallback: (List&amp;lt;String&amp;gt;?, Exception?) -&amp;gt; Unit) {
    try {
        //  耗时任务
        doneCallback(results, null)
    } catch (e: Exception) {
        doneCallback(null, e)
    }
}
//  调用该方法
findCountries{ list, e -&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到使用闭包后无需预先定义回调接口，方便很多。&lt;/p&gt;

&lt;h3 id=&#34;使用-kotlin-function-extension:9d05dee5736f4f1c0148629e5dc91f56&#34;&gt;使用 Kotlin Function Extension&lt;/h3&gt;

&lt;p&gt;通常我们会将很多方法放在工具类里，不过通过 Kotlin 的方法扩展功能可以直接将部分功能移到 &lt;code&gt;Activity&lt;/code&gt; 中。&lt;/p&gt;

&lt;p&gt;例：为 &lt;code&gt;Activity&lt;/code&gt; 增加 &lt;code&gt;Toast&lt;/code&gt; 功能&lt;/p&gt;

&lt;p&gt;增加方法扩展&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public fun Activity.toast(message: CharSequence?, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, message, duration).show()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后在 &lt;code&gt;Activity&lt;/code&gt; 中就可以调用以下代码直接呼出 &lt;code&gt;Toast&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;toast(message)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例：为 &lt;code&gt;Activity&lt;/code&gt; 添加画面跳转功能&lt;/p&gt;

&lt;p&gt;增加方法扩展&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;inline public fun &amp;lt;reified T : Activity&amp;gt; Activity.navigate(bundle: Bundle? = null) {
    val intent = Intent(this, T::class.java)
    if (bundle != null) {
        intent.putExtras(bundle)
    }
    startActivity(intent)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后在 &lt;code&gt;Activity&lt;/code&gt; 中就可以调用以下代码直接进行画面跳转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;navigate&amp;lt;CountryListActivity&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整的 Android 示例见 &lt;a href=&#34;https://github.com/SidneyXu/templates/tree/master/KotlinAndroid&#34;&gt;KotlinAndroid&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Groovy 开发 Android 应用</title>
      <link>http://git.bookislife.com/post/2015/dev-android-using-groovy/</link>
      <pubDate>Mon, 30 Nov 2015 10:04:55 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/dev-android-using-groovy/</guid>
      <description>

&lt;h1 id=&#34;groovy-android:37dae454deb5adb67c3953dd4e915b1f&#34;&gt;Groovy Android&lt;/h1&gt;

&lt;h2 id=&#34;场景:37dae454deb5adb67c3953dd4e915b1f&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;我们都知道 Android 原生应用基本都是使用 Java 开发的，但是实际上 Groovy 也是运行在 JVM 上的，所以也可以用于开发 Android 应用程序，只是需要做一些额外的准备工作。&lt;/p&gt;

&lt;h2 id=&#34;环境配置:37dae454deb5adb67c3953dd4e915b1f&#34;&gt;环境配置&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;既然是使用 Groovy 语言进行开发，所以第一步就是在 IDEA 或 Android Studio 中安装 &lt;code&gt;Groovy&lt;/code&gt; 插件。步骤：打开 &lt;code&gt;Settings&lt;/code&gt; 或 &lt;code&gt;Preferences&lt;/code&gt; 选择 &lt;code&gt;Plugins&lt;/code&gt;，点击 &lt;code&gt;Browser repositories&lt;/code&gt; 输入 &lt;code&gt;Groovy&lt;/code&gt; 进行安装，安装完后重启 IDE。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建立一个空的 Android 项目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改 &lt;code&gt;build.gradle&lt;/code&gt; 文件&lt;/p&gt;

&lt;p&gt;添加 &lt;code&gt;gradle-groovy-android-plugin&lt;/code&gt; 插件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:1.2.3&#39;
        classpath &#39;org.codehaus.groovy:gradle-groovy-android-plugin:0.3.6&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 plugin&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply plugin: &#39;groovyx.grooid.groovy-android&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加 runtime&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    compile &#39;org.codehaus.groovy:groovy:2.4.5:grooid&#39;
    // 如果需要使用  Groovy 的 JSON Api 的话还需要配置下面的依赖
    compile(&#39;org.codehaus.groovy:groovy-json:2.4.5&#39;) {
        transitive = false
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;配置 packagingOptions&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;packagingOptions {
    exclude &#39;META-INF/LICENSE.txt&#39;
    exclude &#39;META-INF/LICENSE&#39;
    exclude &#39;META-INF/NOTICE&#39;
    exclude &#39;META-INF/DISCLAIMER&#39;
    exclude &#39;META-INF/groovy-release-info.properties&#39;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完整的 &lt;code&gt;build.gradle&lt;/code&gt; 文件可以见 &lt;a href=&#34;https://github.com/SidneyXu/templates/blob/master/GroovyAndroid/app/build.gradle&#34;&gt;示例&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;4.配置 proguard&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-dontobfuscate
-keep class org.codehaus.groovy.vmplugin.**
-keep class org.codehaus.groovy.runtime.dgm*
-keepclassmembers class org.codehaus.groovy.runtime.dgm* {
    *;
}

-keepclassmembers class ** implements org.codehaus.groovy.runtime.GeneratedClosure {
    *;
}

-dontwarn org.codehaus.groovy.**
-dontwarn groovy**
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编写代码:37dae454deb5adb67c3953dd4e915b1f&#34;&gt;编写代码&lt;/h2&gt;

&lt;h3 id=&#34;使用静态编译:37dae454deb5adb67c3953dd4e915b1f&#34;&gt;使用静态编译&lt;/h3&gt;

&lt;p&gt;如果不需要使用动态编译的话，可以开启静态编译以获得更好的性能，使用方法就是在类上添加 &lt;code&gt;@CompileStatic&lt;/code&gt; 注解。开启静态编译后一些正常的 Groovy 代码可能无法正常运行，因为静态编译会对类型进行严格的检查，所以代码风格可能需要做出一定改变。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;@CompileStatic
class MainActivity extends AppCompatActivity
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-groovy-的语法:37dae454deb5adb67c3953dd4e915b1f&#34;&gt;使用 Groovy 的语法&lt;/h3&gt;

&lt;p&gt;使用 Groovy 后可以省略方法的返回值，省略分号，也可以使用更优雅的类型转换方式。&lt;/p&gt;

&lt;p&gt;Java 的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
View getView(final int position, final View convertView, final ViewGroup parent) {
    View view = super.getView(position, convertView, parent);
    TextView title = view.findViewById(android.R.id.text1);
    title.setText(getItem(position));
    return view;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Groovy 的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;@Override
View getView(final int position, final View convertView, final ViewGroup parent) {
    View view = super.getView(position, convertView, parent)
    def title = view.findViewById(android.R.id.text1) as TextView
    title.setText(getItem(position))
    view
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用闭包替代匿名类:37dae454deb5adb67c3953dd4e915b1f&#34;&gt;使用闭包替代匿名类&lt;/h3&gt;

&lt;p&gt;匿名类的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;findViewById(android.R.id.button1).setOnClickListener(new View.OnClickListener() {
    @Override
    void onClick(final View v) {
        startActivity(new Intent(MainActivity.this, CountryListActivity.class))
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;闭包的写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;findViewById(android.R.id.button1).onClickListener = {
    startActivity(new Intent(this, CountryListActivity.class))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到使用闭包替代的话代码可以简单不少，不过使用闭包后如果闭包中碰到需要调用当前 Activity 的上下文时比较难处理，需要注意 &lt;code&gt;this&lt;/code&gt;，&lt;code&gt;owner&lt;/code&gt;，&lt;code&gt;delegate&lt;/code&gt; 的区别。&lt;/p&gt;

&lt;h3 id=&#34;使用闭包替代回调:37dae454deb5adb67c3953dd4e915b1f&#34;&gt;使用闭包替代回调&lt;/h3&gt;

&lt;p&gt;由于 Android 的机制，网络请求必须放在其它的线程中执行，所以使用 Java 编程时通常都需要定义各种回调接口用于通知耗时任务的完成。&lt;/p&gt;

&lt;p&gt;Java 的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//  定义回调接口
public interface FindCallback {
    void onFinish(List&amp;lt;String&amp;gt; results, Exception e);
}
//  定义耗时任务
void findCountries(FindCallback doneCallback) {
    try {
        //  耗时任务
        doneCallback.onFinish(results, null);
    } catch (Exception e) {
        doneCallback.onFinish(null, e);
    }
}
//  调用该方法
findCountries(new FindCallback(){
    void onFinish(List&amp;lt;String&amp;gt; results, Exception e){
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Groovy 的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;//  定义耗时任务
void findCountries(Closure doneCallback) {
    try {
        //  耗时任务
        doneCallback(results, null)
    } catch (e) {
        doneCallback(null, e)
    }
}
//  调用该方法
findCountries{ List&amp;lt;String&amp;gt; results, Exception e -&amp;gt;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到使用闭包后无需预先定义回调接口，方便很多。&lt;/p&gt;

&lt;p&gt;完整的 Android 示例见 &lt;a href=&#34;https://github.com/SidneyXu/templates/tree/master/GroovyAndroid&#34;&gt;GroovyAndroid&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Robolectric&#43;Assertj&#43;PowerMock搭建 Android 的逻辑测试环境</title>
      <link>http://git.bookislife.com/post/2015/robolectricassertjpowermock-android-logic-test/</link>
      <pubDate>Fri, 25 Sep 2015 11:59:24 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/robolectricassertjpowermock-android-logic-test/</guid>
      <description>

&lt;h2 id=&#34;编写-build-gradle-文件:c1a394b152ef0d4309188522b62d407d&#34;&gt;编写 &lt;code&gt;build.gradle&lt;/code&gt; 文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {
    //  Robolectric
    testCompile &amp;quot;org.robolectric:robolectric:3.0&amp;quot;
    
    //  AssertJ 
    testCompile &#39;com.squareup.assertj:assertj-android:1.1.0&#39;

    //  PowerMock + Mockito
    testCompile &#39;org.powermock:powermock-module-junit4:1.6.2&#39;
    testCompile &amp;quot;org.powermock:powermock-module-junit4-rule:1.6.2&amp;quot;
    testCompile &#39;org.powermock:powermock-api-mockito:1.6.2&#39;
    testCompile &amp;quot;org.powermock:powermock-classloading-xstream:1.6.2&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编写测试代码:c1a394b152ef0d4309188522b62d407d&#34;&gt;编写测试代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(RobolectricGradleTestRunner.class)
@Config(sdk = 21,
        constants = BuildConfig.class, manifest = &amp;quot;build/intermediates/bundles/debug/AndroidManifest.xml&amp;quot;)
@PowerMockIgnore({&amp;quot;org.mockito.*&amp;quot;, &amp;quot;org.robolectric.*&amp;quot;, &amp;quot;android.*&amp;quot;})
@PrepareForTest(Calc.class)
public class RobolectricPowerMockTest {

    @Rule
    public PowerMockRule rule = new PowerMockRule();

    @Before
    public void setup() {
    }

    @After
    public void teardown() {
    }

    @Test
    public void sample() {
        Context context = RuntimeEnvironment.application.getApplicationContext();
        assertThat(
                context.getString(R.string.app_name), is(&amp;quot;example-android-lib&amp;quot;));
    }

    @Test
    public void testCalc() {
        PowerMockito.mockStatic(Calc.class);
        Mockito.when(Calc.add(1, 2)).thenReturn(10);

        assertThat(Calc.add(1, 2), is(10));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运行测试:c1a394b152ef0d4309188522b62d407d&#34;&gt;运行测试&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;./gradlew clean testDebug
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;查看测试报告:c1a394b152ef0d4309188522b62d407d&#34;&gt;查看测试报告&lt;/h2&gt;

&lt;p&gt;测试结果位于 &lt;code&gt;build/outputs/reports/tests/debug/index.html&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Espresso&#43;Assertj&#43;Mockito搭建Android的UI测试环境</title>
      <link>http://git.bookislife.com/post/2015/espressoassertjmockito-android-ui-test/</link>
      <pubDate>Fri, 25 Sep 2015 11:58:50 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/espressoassertjmockito-android-ui-test/</guid>
      <description>

&lt;h2 id=&#34;编写-build-gradle-文件:b77b76b1cc744eb25e1afe37b2e6854d&#34;&gt;编写 &lt;code&gt;build.gradle&lt;/code&gt; 文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;android {
    packagingOptions {
        exclude &#39;LICENSE.txt&#39;
        exclude &#39;LICENSE&#39;
        exclude &#39;NOTICE&#39;
        exclude &#39;asm-license.txt&#39;
    }
    defaultConfig {
        testInstrumentationRunner &amp;quot;android.support.test.runner.AndroidJUnitRunner&amp;quot;
    }
}

dependencies {
    androidTestCompile &#39;com.squareup.assertj:assertj-android:1.1.0&#39;
    androidTestCompile &#39;com.android.support.test:runner:0.3&#39;
    androidTestCompile &#39;com.android.support.test:rules:0.3&#39;
    androidTestCompile &#39;com.android.support.test.espresso:espresso-core:2.2&#39;

    androidTestCompile &#39;org.mockito:mockito-core:1.9.5&#39;
    androidTestCompile &#39;com.google.dexmaker:dexmaker:1.2&#39;
    androidTestCompile &#39;com.google.dexmaker:dexmaker-mockito:1.2&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编写测试代码:b77b76b1cc744eb25e1afe37b2e6854d&#34;&gt;编写测试代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(AndroidJUnit4.class)
@LargeTest
public class EspressoMockTest {

    @Rule
    public ActivityTestRule&amp;lt;CalculatorActivity&amp;gt; activityTestRule
            = new ActivityTestRule&amp;lt;&amp;gt;(CalculatorActivity.class);

    @Test
    public void testAdd() {
        onView(ViewMatchers.withId(R.id.number1)).perform(typeText(&amp;quot;2&amp;quot;));
        onView(ViewMatchers.withId(R.id.number2)).perform(typeText(&amp;quot;20&amp;quot;));

        onView(ViewMatchers.withId(R.id.calc)).perform(click());

        onView(ViewMatchers.withId(R.id.result)).check(matches(ViewMatchers.withText(&amp;quot;22&amp;quot;)));
        
        Bean bean = Mockito.mock(Bean.class);
        Mockito.when(bean.getCount()).thenReturn(100);
        Assertions.assertThat(bean.getCount()).isEqualTo(100);
    }
  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运行测试:b77b76b1cc744eb25e1afe37b2e6854d&#34;&gt;运行测试&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;./gradlew connectedAndroidTest
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;查看测试报告:b77b76b1cc744eb25e1afe37b2e6854d&#34;&gt;查看测试报告&lt;/h2&gt;

&lt;p&gt;测试结果位于 &lt;code&gt;build/outputs/reports/androidTests/connected/index.html&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android测试环境选型</title>
      <link>http://git.bookislife.com/post/2015/android%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%80%89%E5%9E%8B/</link>
      <pubDate>Fri, 25 Sep 2015 11:56:51 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/android%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%80%89%E5%9E%8B/</guid>
      <description>

&lt;h2 id=&#34;android-测试工具:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;Android 测试工具&lt;/h2&gt;

&lt;h3 id=&#34;分类:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;分类&lt;/h3&gt;

&lt;p&gt;Android测试按测试范围通常可以分为两种：Logic Test和 UI Test，前者用于测试各种逻辑是否正常执行，很多情况下无需调用Android的api，后者用于测试UI控件的动作响应是否如预期。&lt;/p&gt;

&lt;p&gt;按照测试手段也可以分为两种：Local Test 和 Instrument Test，前者指的是使用JVM直接进行本地测试，通常来说效率要高出不少，后者又称为Connected Test，需要连接模拟器或者才能进行测试。Local Test 的测试代码通常放在 &lt;code&gt;src/test&lt;/code&gt; 目录，且依赖使用 &lt;code&gt;testCompile&lt;/code&gt;声明，Instrument Test 的测试代码通常放在 &lt;code&gt;src/androidTes&lt;/code&gt;目录，且依赖使用 &lt;code&gt;androidTestCompile&lt;/code&gt; 声明。&lt;/p&gt;

&lt;h3 id=&#34;logic-test:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;Logic Test&lt;/h3&gt;

&lt;h4 id=&#34;android-testing-framework:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;Android Testing Framework&lt;/h4&gt;

&lt;p&gt;使用方法&lt;/p&gt;

&lt;p&gt;修改&lt;code&gt;build.gradle&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;defaultConfig {
    testInstrumentationRunner &amp;quot;android.support.test.runner.AndroidJUnitRunner&amp;quot;
}

dependencies {
    androidTestCompile &#39;com.android.support.test:runner:0.3&#39;
    androidTestCompile &#39;com.android.support.test:rules:0.3&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sample&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;

@RunWith(AndroidJUnit4.class)
public class JUnit4Test {

    private Context mContext;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
    }

    @Test
    public void add() {
        assertThat(Calc.add(3, 5), is(8));
    }

    @Test
    public void context() {
        assertThat(mContext.getString(R.string.app_name), is(&amp;quot;example-android-lib&amp;quot;));
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew connectedAndroidTest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果位于 &lt;code&gt;build/outputs/reports/androidTests/connected/index.html&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;robolectric:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;Robolectric&lt;/h4&gt;

&lt;p&gt;Robolectric 运行于 JVM 上，所以效率比起需要连接到模拟器的测试方式要快不少。&lt;/p&gt;

&lt;p&gt;使用方法&lt;/p&gt;

&lt;p&gt;编辑 &lt;code&gt;build.gradle&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {
    testCompile &amp;quot;org.robolectric:robolectric:3.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sample&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(RobolectricTestRunner.class)
@Config(sdk = 21, manifest = &amp;quot;./src/main/AndroidManifest.xml&amp;quot;,
        constants = BuildConfig.class)
public class RobolectricTest {

    @Before
    public void setup() {
    }

    @After
    public void teardown() {
    }

    @Test
    public void sample() {
        Context context = RuntimeEnvironment.application.getApplicationContext();
        assertThat(
                context.getString(R.string.app_name), is(&amp;quot;example-android-lib&amp;quot;));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew clean test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果位于 &lt;code&gt;build/outputs/reports/tests/debug/index.html&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;ui-test:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;UI Test&lt;/h3&gt;

&lt;h4 id=&#34;activityinstrumentationtestcase2-android-instrumentation:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;ActivityInstrumentationTestCase2（Android Instrumentation）&lt;/h4&gt;

&lt;p&gt;使用方法&lt;/p&gt;

&lt;p&gt;修改&lt;code&gt;build.gradle&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;defaultConfig {
    testInstrumentationRunner &amp;quot;android.test.InstrumentationTestRunner&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sample&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ActivityInstrumentationTestCaseTest extends ActivityInstrumentationTestCase2&amp;lt;CalculatorActivity&amp;gt; {

    public ActivityInstrumentationTestCaseTest() {
        super(CalculatorActivity.class);
    }

    public void testAdd() {
         EditText num1EditText = (EditText) getActivity().findViewById(R.id.number1);
        TouchUtils.clickView(this, num1EditText);
        sendKeys(KeyEvent.KEYCODE_1);

        EditText num2EditText = (EditText) getActivity().findViewById(R.id.number2);
        TouchUtils.clickView(this, num2EditText);
        sendKeys(KeyEvent.KEYCODE_1);
        sendKeys(KeyEvent.KEYCODE_0);

        //  Monitor ResultActivity
        Instrumentation.ActivityMonitor monitor
                = new Instrumentation.ActivityMonitor(ResultActivity.class.getCanonicalName(), null, false);
        getInstrumentation().addMonitor(monitor);

        Button calcButton = (Button) getActivity().findViewById(R.id.calc);
        TouchUtils.clickView(this, calcButton);

        Activity resultActivity = getInstrumentation().waitForMonitorWithTimeout(monitor, 5000);

        assertEquals(monitor.getHits(), 1);
        assertNotNull(resultActivity);

        TextView resultTextView = (TextView) resultActivity.findViewById(R.id.result);
        assertEquals(resultTextView.getText().toString(), &amp;quot;11&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew connectedAndroidTest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果位于 &lt;code&gt;build/reports/androidTests/connected/index.html&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;espresso:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;Espresso&lt;/h4&gt;

&lt;p&gt;基于 Android Instrumentation 实现，可以减少测试的代码量。&lt;/p&gt;

&lt;p&gt;使用方法&lt;/p&gt;

&lt;p&gt;修改 &lt;code&gt;build.gradle&lt;/code&gt; 文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;packagingOptions {
    exclude &#39;LICENSE.txt&#39;
}
defaultConfig {
    testInstrumentationRunner &amp;quot;android.support.test.runner.AndroidJUnitRunner&amp;quot;
}
dependencies {
    androidTestCompile &#39;com.android.support.test:runner:0.3&#39;
    androidTestCompile &#39;com.android.support.test:rules:0.3&#39;
    androidTestCompile &#39;com.android.support.test.espresso:espresso-core:2.2&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sample&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(AndroidJUnit4.class)
@LargeTest
public class EspressoTest {

    @Rule
    public ActivityTestRule&amp;lt;CalculatorActivity&amp;gt; activityTestRule
            = new ActivityTestRule&amp;lt;&amp;gt;(CalculatorActivity.class);

    @Test
    public void testAdd() {
        onView(ViewMatchers.withId(R.id.number1)).perform(typeText(&amp;quot;2&amp;quot;));
        onView(ViewMatchers.withId(R.id.number2)).perform(typeText(&amp;quot;20&amp;quot;));

        onView(ViewMatchers.withId(R.id.calc)).perform(click());

        onView(ViewMatchers.withId(R.id.result)).check(matches(ViewMatchers.withText(&amp;quot;22&amp;quot;)));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew connectedAndroidTest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果位于 &lt;code&gt;build/reports/androidTests/connected/index.html&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;robotium:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;Robotium&lt;/h4&gt;

&lt;p&gt;基于 Android Instrumentation 开发，类似 Espresso。&lt;/p&gt;

&lt;p&gt;使用方法&lt;/p&gt;

&lt;p&gt;修改 &lt;code&gt;build.gradle&lt;/code&gt; 文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;defaultConfig {
    testInstrumentationRunner &amp;quot;android.support.test.runner.AndroidJUnitRunner&amp;quot;
}

dependencies {
    androidTestCompile &#39;com.jayway.android.robotium:robotium-solo:5.4.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sample&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(AndroidJUnit4.class)
@LargeTest
public class RobotiumTest extends ActivityInstrumentationTestCase2&amp;lt;CalculatorActivity&amp;gt; {

    public RobotiumTest() {
        super(CalculatorActivity.class);
    }

    @Before
    @Override
    public void setUp() throws Exception {
        super.setUp();
        injectInstrumentation(InstrumentationRegistry.getInstrumentation());
    }

    @Test
    public void testAdd() {
        Solo solo = new Solo(getInstrumentation(), getActivity());

        solo.enterText(0, &amp;quot;3&amp;quot;);
        solo.enterText(1, &amp;quot;30&amp;quot;);

        solo.clickOnButton(&amp;quot;=&amp;quot;);

        solo.assertCurrentActivity(&amp;quot;Current is ResultActivity&amp;quot;, ResultActivity.class);

        assertThat(solo.searchText(&amp;quot;33&amp;quot;), is(true));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew connectedAndroidTest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果位于 `build/reports/androidTests/connected/index.html&lt;/p&gt;

&lt;h4 id=&#34;uiautomator:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;UIAutomator&lt;/h4&gt;

&lt;p&gt;需要Android 4.3以上机器才支持，所以暂时不做考虑&lt;/p&gt;

&lt;h4 id=&#34;appium:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;Appium&lt;/h4&gt;

&lt;p&gt;支持 Java， Javascript 等多种编程语言编写测试用例，可以运行在 Android 和 IOS 上，底层实际是调用了对应平台的测试框架。本身搭建测试环境等相比较传统测试方法略微复杂。相比较而言更适合专门的测试人员测试多种平台的功能统一性，不是太适合只进行某一平台开发的开发人员。&lt;/p&gt;

&lt;h3 id=&#34;总结:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;总结&lt;/h3&gt;

&lt;h4 id=&#34;测试工具:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;测试工具&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;工具&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;用途&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;测试方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Android Testing&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;logic&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;connect&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Robolectric&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;logic&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;local&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Instrumentation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ui&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;connect&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Espresso&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ui&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;connect&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Robotium&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ui&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;connect&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Appium&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ui&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;connect&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;断言工具:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;断言工具&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Hamcrest

&lt;ul&gt;
&lt;li&gt;junit 依赖的断言工具，语法类似 &lt;code&gt;assertThat(actual, is(expected))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;AssertJ&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Java平台非常流行的断言工具，square还特别开发了android版本，语法类似 &lt;code&gt;assertThat(actual).isEqualTo(expected)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;mock-工具:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;Mock 工具&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mockito&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;老牌mock工具&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PowerMock&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对Mockito的工具进行了扩展，但是与Dexmaker相性并不好&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ci-服务:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;CI 服务&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Travis CI&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github上最有名的CI服务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Wercker&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持 Bitbucket&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;选型:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;选型&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Logic Test&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用 Robolectric + AssertJ + PowerMock + Travis CI/Wercker&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UI Test&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用 Espresso + AssertJ + Mockito + Travis CI/Wercker&lt;/p&gt;

&lt;h2 id=&#34;坑:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;坑&lt;/h2&gt;

&lt;h3 id=&#34;发生异常-bad-class-file-magic-cafebabe-or-version-0034-0000:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;发生异常 bad class file magic (cafebabe) or version (0034.0000)&lt;/h3&gt;

&lt;p&gt;UNEXPECTED TOP-LEVEL EXCEPTION:com.android.dx.cf.iface.ParseException: bad class file magic (cafebabe) or version (0034.0000)&lt;/p&gt;

&lt;p&gt;原因：使用了 Java 1.8 进行编译&lt;/p&gt;

&lt;p&gt;修复：&lt;/p&gt;

&lt;p&gt;Android 项目&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_7
    targetCompatibility JavaVersion.VERSION_1_7
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用的 Java 项目&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;sourceCompatibility = &#39;1.7&#39;
targetCompatibility = &#39;1.7&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;robolectric-报找不到-androidmanifest-xml-文件:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;Robolectric 报找不到 AndroidManifest.xml 文件&lt;/h3&gt;

&lt;p&gt;报 &amp;ldquo;WARNING: No manifest file found at ./AndroidManifest.xml.Falling back to the Android OS resources only.&lt;/p&gt;

&lt;p&gt;To remove this warning, annotate your test class with @Config(manifest=Config.NONE).&amp;rdquo;&lt;/p&gt;

&lt;p&gt;修复：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;manifest = &amp;quot;./src/main/AndroidManifest.xml&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;参考资料:d5e65750c7dbf671794d81ffb52c8428&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/shikato/items/071a4c879b5c3f0b46f0#espresso&#34;&gt;Androidのテスティングフレームワークを選定してみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bignerdranch.com/blog/all-in-together-android-studio-gradle-and-robolectric/&#34;&gt;All in Together: Android Studio, Gradle and Robolectric&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何开发 JNI 应用</title>
      <link>http://git.bookislife.com/post/2015/how-to-develop-jni-app/</link>
      <pubDate>Wed, 23 Sep 2015 11:55:29 +0800</pubDate>
      
      <guid>http://git.bookislife.com/post/2015/how-to-develop-jni-app/</guid>
      <description>

&lt;h2 id=&#34;传统-jni-开发步骤:6a26598dccbc474410e9b9e3c353078a&#34;&gt;传统 JNI 开发步骤&lt;/h2&gt;

&lt;h3 id=&#34;总述:6a26598dccbc474410e9b9e3c353078a&#34;&gt;总述&lt;/h3&gt;

&lt;p&gt;Android 的 JNI 开发一般可以总结为以下步骤&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编写含有 Native 方法的 Java 类&lt;/li&gt;
&lt;li&gt;用 javah 生成 C/C++ 原生函数的头文件&lt;/li&gt;
&lt;li&gt;用 C/C++ 实现原生函数&lt;/li&gt;
&lt;li&gt;将项目依赖的原生库和资源添加到工程中&lt;/li&gt;
&lt;li&gt;生成应用&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;在类中追加-native-方法:6a26598dccbc474410e9b9e3c353078a&#34;&gt;在类中追加 native 方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Hello {
    public native String hellojni();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;生成头文件:6a26598dccbc474410e9b9e3c353078a&#34;&gt;生成头文件&lt;/h3&gt;

&lt;p&gt;在当前模块目录下追加一个 shell 文件，该文件用于生成头文件&lt;/p&gt;

&lt;p&gt;hello.sh&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
export ProjectPath=$(cd &amp;quot;.&amp;quot;; pwd)
#echo $ProjectPath

export TargetClassName=&amp;quot;com.example.jni.Hello&amp;quot;
export SourceFile=&amp;quot;${ProjectPath}/src/main/java&amp;quot;
export TargetPath=&amp;quot;${ProjectPath}/src/main/jni&amp;quot;

#echo $SourceFile
cd &amp;quot;${SourceFile}&amp;quot;
javah -d ${TargetPath} -classpath &amp;quot;${SourceFile}&amp;quot; &amp;quot;${TargetClassName}&amp;quot;
echo -d ${TargetPath} -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TargetClassName&lt;/code&gt; 为含有 native 方法的类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SourceFile&lt;/code&gt; 为 Java 源代码目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TargetPath&lt;/code&gt; 为 jni 源代码目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行 shell 文件 &lt;code&gt;sh hello.sh&lt;/code&gt;，在目录 &lt;code&gt;src/main/jni&lt;/code&gt; 下会发现生成的.h 头文件&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;p&gt;com_example_jni_Hello.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* DO NOT EDIT THIS FILE - it is machine generated */
#include &amp;lt;jni.h&amp;gt;
/* Header for class com_example_jni_Hello */

#ifndef _Included_com_example_jni_Hello
#define _Included_com_example_jni_Hello
#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
/*
 * Class:     com_example_jni_Hello
 * Method:    hellojni
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_jni_Hello_hellojni
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;编写-jni-代码:6a26598dccbc474410e9b9e3c353078a&#34;&gt;编写 JNI 代码&lt;/h3&gt;

&lt;p&gt;根据头文件，在 jni 目录下创建对应的.c/.cpp 文件，完成代码&lt;/p&gt;

&lt;p&gt;例&lt;/p&gt;

&lt;p&gt;hello.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;com_example_jni_Hello.h&amp;quot;
/*
 * Class:     com_example_jni_Hello
 * Method:    hellojni
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_jni_Hello_hellojni
  (JNIEnv *env, jobject){
    return env-&amp;gt;NewStringUTF( &amp;quot;hello from jni&amp;quot;);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;配置-ndk-环境:6a26598dccbc474410e9b9e3c353078a&#34;&gt;配置 NDK 环境&lt;/h3&gt;

&lt;p&gt;下载 NDK，并在工程目录下新建 &lt;code&gt;local.properties&lt;/code&gt; 文件，在其中追加 &lt;code&gt;ndk.dir&lt;/code&gt; 属性，值为 NDK 的路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ndk.dir=/Users/localUser/Documents/android-ndk-r10d
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;编译-jni-代码:6a26598dccbc474410e9b9e3c353078a&#34;&gt;编译 JNI 代码&lt;/h3&gt;

&lt;p&gt;选择当前模块 -&amp;gt; 右键选择 &lt;code&gt;Make Module&lt;/code&gt; 后编译代码，完成后在 &lt;code&gt;build/intermediates/ndk&lt;/code&gt; 目录下会生成对应的 &lt;code&gt;Android.mk&lt;/code&gt; 文件和 &lt;code&gt;xx.so&lt;/code&gt; 文件（如果出现错误，需要注意 ndk 下的 &lt;code&gt;platform&lt;/code&gt; 目录下是否有当前的 sdk 版本，没有的话需要更新 ndk）。&lt;/p&gt;

&lt;h3 id=&#34;载入-library-运行代码:6a26598dccbc474410e9b9e3c353078a&#34;&gt;载入 Library，运行代码&lt;/h3&gt;

&lt;p&gt;打开拥有 native 方法的类，加入以下语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static {
  System.loadLibrary(libraryName );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;libraryName&lt;/code&gt; 就是上一节 &lt;code&gt;Android.mk&lt;/code&gt; 文件中的 &lt;code&gt;LOCAL_MODULE&lt;/code&gt; 名，Gradle 默认生成的 &lt;code&gt;libraryName&lt;/code&gt; 就是当前的模块名，所以如果你用默认配置的话应该就是 &lt;code&gt;app&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以上都完成后，就可以运行代码查看效果了。&lt;/p&gt;

&lt;h3 id=&#34;自定义配置:6a26598dccbc474410e9b9e3c353078a&#34;&gt;自定义配置&lt;/h3&gt;

&lt;p&gt;包含 moduleName 等可以通过修改 build.gradle 文件进行一些自定义配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;debug {
  ndk {
    //  自定义 library 名
    moduleName &amp;quot;jnimain&amp;quot;

    //  指定生成的 xx.so 平台
    abiFilters &amp;quot;armeabi&amp;quot;, &amp;quot;armeabi-v7a&amp;quot;

    stl &amp;quot;stlport_shared&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基于最新-android-studio-进行-jni-开发:6a26598dccbc474410e9b9e3c353078a&#34;&gt;基于最新 Android Studio 进行 JNI 开发&lt;/h2&gt;

&lt;p&gt;最新的 Android Studio 使用了新的一套配置来进行 JNI 开发，并且其内置了 NDK 的 Debug 机能。不过目前这种配置还是实验性的，所以与以前的方式相比较需要改动不少地方。&lt;/p&gt;

&lt;h3 id=&#34;环境:6a26598dccbc474410e9b9e3c353078a&#34;&gt;环境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Android Studio 1.3 RC1 以上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Gradle 2.5，目前仅支持 2.5，其它版本的 Gradle 都不行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlqqp.com1.z0.glb.clouddn.com/jni/sdk.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;修改-build-gradle-配置:6a26598dccbc474410e9b9e3c353078a&#34;&gt;修改 build.gradle 配置&lt;/h3&gt;

&lt;p&gt;根目录 build.gradle&lt;/p&gt;

&lt;p&gt;注意 &lt;code&gt;classpath&lt;/code&gt; 由原来的 &lt;code&gt;classpath &#39;com.android.tools.build:gradle:1.3.+’&lt;/code&gt; 变为了以下这种&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle-experimental:0.2.0&#39;
    }
}

allprojects {
    repositories {
        jcenter()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;工程目录 build.gradle&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;apply plugin: &#39;com.android.model.application&#39;

repositories {
    jcenter()
}

model {
    android {
        compileSdkVersion = 22
        buildToolsVersion = &amp;quot;22.0.1&amp;quot;

        defaultConfig.with {
            applicationId = &amp;quot;com.example.jni&amp;quot;
            minSdkVersion.apiLevel = 9
            targetSdkVersion.apiLevel = 22
            versionCode = 1
            versionName = &amp;quot;1.0&amp;quot;
        }
    }
    android.buildTypes {
        release {
            minifyEnabled = false
            proguardFiles += file(&#39;proguard-rules.pro&#39;)
        }
        debug {
            ndk.with {
                debuggable = true
            }
        }
    }
    android.ndk {
        moduleName = &amp;quot;app&amp;quot;
    }
    compileOptions.with {
        sourceCompatibility = JavaVersion.VERSION_1_7
        targetCompatibility = JavaVersion.VERSION_1_7
    }
}

dependencies {
    compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)
    compile &#39;com.android.support:appcompat-v7:22.2.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意几点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;plugin 由 &lt;code&gt;com.android.application&lt;/code&gt; 变为 &lt;code&gt;com.android.model.application&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;android{}&lt;/code&gt; 移到了 &lt;code&gt;model{}&lt;/code&gt; 下&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;minSdkVersion&lt;/code&gt; 等变为了 &lt;code&gt;minSdkVersion.apiLevel&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;defaultConfig&lt;/code&gt; 等变为了 &lt;code&gt;defaultConfig.with&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;compileSdkVersion 22&lt;/code&gt; 之类的都变成了 &lt;code&gt;compileSdkVersion = 22&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;进行-debug:6a26598dccbc474410e9b9e3c353078a&#34;&gt;进行 Debug&lt;/h3&gt;

&lt;p&gt;以上修改完毕后，选择 &lt;code&gt;Edit Configurations&lt;/code&gt; -&amp;gt; 新建 &lt;code&gt;Android Native&lt;/code&gt;，以 Debug 形式运行此配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlqqp.com1.z0.glb.clouddn.com/jni/config.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;在工程的 native 代码中打上断点，就可以进行 native 代码相关的 debug 了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlqqp.com1.z0.glb.clouddn.com/jni/debug.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;参考资料:6a26598dccbc474410e9b9e3c353078a&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tools.android.com/tech-docs/android-ndk-preview&#34;&gt;Android NDK Preview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tools.android.com/tech-docs/new-build-system/gradle-experimental&#34;&gt;Experimental Plugin User Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/eaglesakura/items/c4af7989b03904d66ebe&#34;&gt;Android StudioのNDK開発機能を使おう！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整的 Android 示例见 &lt;a href=&#34;https://github.com/SidneyXu/templates/tree/master/hello-jni&#34;&gt;hello-jni&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>